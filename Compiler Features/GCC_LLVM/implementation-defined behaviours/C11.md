

# Implementation-defined Behaviors

## 1. Translation

### 1. How a diagnostic is identified ([3.10](https://port70.net/~nsz/c/c11/n1570.html#3.10), [5.1.1.3](https://port70.net/~nsz/c/c11/n1570.html#5.1.1.3)).

- å¦‚ä½•è¯†åˆ«è¯Šæ–­
- Diagnostics consist of all the output sent to stderr by LLVM/Clang.

```c
#include <stdio.h>

int main(){
    int a=1;
    a = i;
    return 0;
}
```

ç»“æœå¦‚ä¸‹ï¼š

```bash
$ make gcc
gcc --std=c11 ./test.c -o target_gcc
./test.c: In function â€˜mainâ€™:
./test.c:5:9: error: â€˜iâ€™ undeclared (first use in this function)
    5 |     a = i;
      |         ^
./test.c:5:9: note: each undeclared identifier is reported only once for each function it appears in
make: *** [Makefile:13: gcc] Error 1
```

```bash
$ make clang 
clang --std=c11 ./test.c -o target_clang
./test.c:5:9: error: use of undeclared identifier 'i'
    a = i;
        ^
1 error generated.
make: *** [Makefile:17: clang] Error 1
```

ä¸GCCä¸€è‡´ã€‚

### 2. Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character in translation phase 3 ([5.1.1.2](https://port70.net/~nsz/c/c11/n1570.html#5.1.1.2)).

- åœ¨ç¿»è¯‘é˜¶æ®µ3ä¸­ï¼Œæ˜¯å¦ä¿ç•™æ¯ä¸ªéç©ºçš„ç©ºç™½å­—ç¬¦åºåˆ—ï¼ˆæ¢è¡Œç¬¦é™¤å¤–ï¼‰æˆ–è€…ç”¨ä¸€ä¸ªç©ºæ ¼å­—ç¬¦æ›¿æ¢å®ƒ
- In textual output, each whitespace sequence is collapsed to a single space. For aesthetic reasons, the first token on each non-directive line of output is preceded with sufficient spaces that it appears in the same column as it did in the original source file.
- åŒ…å«åˆ¶è¡¨ç¬¦ (\t)ã€æ¢é¡µ (\f) æˆ–çºµå‘è¾“å…¥ (\v) çš„éç©ºå­—ç¬¦åºåˆ—å°†æ›¿æ¢ä¸ºä¸€ä¸ªç©ºæ ¼å­—ç¬¦ã€‚

```c
int                 main(){
    int a=1;
    return 0;
}
```

ç»è¿‡é¢„å¤„ç†å(æ‰§è¡Œ`make preprocess_gcc`ä¸`make preprocess_clang`)ç»“æœåˆ†åˆ«å¦‚ä¸‹ï¼š

```c
//output_gcc:
# 0 "./test.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "./test.c"
int main(){
    int a=1;
    return 0;
}

```

```c
//output_clang:
# 1 "./test.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 360 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "./test.c" 2
int main(){
    int a=1;
    return 0;
}

```

ä¸GCCä¸€è‡´ã€‚

## 2. Environment

The behavior of most of these points are dependent on the implementation of the **C library**.

å³æœ‰éƒ¨åˆ†å®ç°å®šä¹‰è¡Œä¸ºå¹¶æœªç”±GCCæˆ–LLVMå†³å®šï¼Œå¯èƒ½ç”±Cæ ‡å‡†åº“å®ç°æˆ–è€…Cæ ‡å‡†å†³å®šï¼Œè¿™äº›è¡Œä¸ºå·²åœ¨æœ¬æ–‡æ¡£ä¸­æ˜ç¡®æŒ‡æ˜ã€‚

### 1. The mapping between physical source file multibyte characters and the source character set in translation phase 1 ([5.1.1.2](https://port70.net/~nsz/c/c11/n1570.html#5.1.1.2)).

- ç¿»è¯‘é˜¶æ®µ1ä¸­ç‰©ç†æºæ–‡ä»¶å¤šå­—èŠ‚å­—ç¬¦ä¸æºå­—ç¬¦é›†ä¹‹é—´çš„æ˜ å°„ã€‚

- GCC:
  - The input character set can be specified using the -finput-charset option, while the execution character set may be controlled using the -fexec-charset and -fwide-exec-charset options.
  - GCC å¯ä»¥æŒ‡å®šè¾“å…¥æºæ–‡ä»¶çš„å­—ç¬¦é›†å’Œæ‰§è¡Œå­—ç¬¦é›†ã€‚é»˜è®¤ä¸ºUTF-8

- ä½†æ˜¯clangæ— æ³•åšåˆ°è¿™ä¸€ç‚¹ï¼ŒLLVM's execution character set is always UTF-8 with respect to the C standardï¼Œè¾“å…¥æºæ–‡ä»¶ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå¦‚æœä½¿ç”¨äº†å…¶ä»–å­—ç¬¦é›†ï¼Œå¹¶ä¸”åŒ…å«é UTF-8 ç¼–ç çš„å¤šå­—èŠ‚å­—ç¬¦ï¼ŒClang å¯èƒ½ä¼šæ— æ³•æ­£ç¡®è§£æè¿™äº›å­—ç¬¦ã€‚

  - [Character set - llvm-mos](https://llvm-mos.org/wiki/Character_set)

- äº‹å®ä¸Šï¼Œç¤¾åŒºé‡Œæœ‰äººè¯•å›¾å®ç°fexec-charset support

  [RFC: Enabling fexec-charset support to LLVM and clang (Reposting) - Clang Frontend - LLVM Discussion Forums](https://discourse.llvm.org/t/rfc-enabling-fexec-charset-support-to-llvm-and-clang-reposting/71512)

### 2. The name and type of the function called at program startup in a freestanding environment ([5.1.2.1](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.1)).

- åœ¨ç‹¬ç«‹ç¯å¢ƒä¸­ï¼Œç¨‹åºå¯åŠ¨æ—¶è°ƒç”¨çš„å‡½æ•°çš„åç§°å’Œç±»å‹ã€‚

- Not defined by GCC or LLVM themself.

### 3. The effect of program termination in a freestanding environment ([5.1.2.1](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.1)).

- åœ¨ç‹¬ç«‹ç¯å¢ƒä¸­ç¨‹åºç»ˆæ­¢çš„å½±å“

- Not defined by GCC or LLVM themself.

### 4. An alternative manner in which the main function may be defined ([5.1.2.2.1](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.1)).

- å®šä¹‰ `main` å‡½æ•°çš„å¦ä¸€ç§æ–¹å¼

- Not defined by GCC or LLVM themself.

- C11æ ‡å‡†ï¼š

  - > - [1](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.1p1) The function called at program startup is named main. The implementation declares no prototype for this function. It shall be defined with a return type of int and with no parameters:
    >
    >   ```
    >            int main(void) { /* ... */ }
    >   ```
    >
    >   or with two parameters (referred to here as argc and argv, though any names may be used, as they are local to the function in which they are declared):
    >
    >   ```
    >            int main(int argc, char *argv[]) { /* ... */ }
    >   ```
    >
    >   or equivalent;[**10)**](https://port70.net/~nsz/c/c11/n1570.html#note10) or in some other implementation-defined manner.
    >
    >   [2](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.1p2) If they are declared, the parameters to the main function shall obey the following constraints:
    >
    >   - The value of argc shall be nonnegative.
    >   - argv[argc] shall be a null pointer.
    >   - If the value of argc is greater than zero, the array members argv[0] through argv[argc-1] inclusive shall contain pointers to strings, which are given implementation-defined values by the host environment prior to program startup. The intent is to supply to the program information determined prior to program startup from elsewhere in the hosted environment. If the host environment is not capable of supplying strings with letters in both uppercase and lowercase, the implementation shall ensure that the strings are received in lowercase.
    >   - If the value of argc is greater than zero, the string pointed to by argv[0] represents the program name; argv[0][0] shall be the null character if the program name is not available from the host environment. If the value of argc is greater than one, the strings pointed to by argv[1] through argv[argc-1] represent the program parameters.
    >   - The parameters argc and argv and the strings pointed to by the argv array shall be modifiable by the program, and retain their last-stored values between program startup and program termination.

### 5. The values given to the strings pointed to by the argv argument to main ([5.1.2.2.1](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.1)).

- ä¼ é€’ç»™ `main` å‡½æ•°çš„ `argv` å‚æ•°æ‰€æŒ‡å‘çš„å­—ç¬¦ä¸²çš„å€¼ã€‚

- Not defined by GCC or LLVM themself.

- C99æ ‡å‡†ï¼š

  - > [1](https://port70.net/~nsz/c/c99/n1256.html#5.1.2.2.1p1) The function called at program startup is named main. The implementation declares no prototype for this function. It shall be defined with a return type of int and with no parameters:
    >
    > ```
    >          int main(void) { /* ... */ }
    > ```
    >
    > or with two parameters (referred to here as argc and argv, though any names may be used, as they are local to the function in which they are declared):
    >
    > ```
    >          int main(int argc, char *argv[]) { /* ... */ }
    > ```
    >
    > or equivalent;[**9)**](https://port70.net/~nsz/c/c99/n1256.html#note9) or in some other implementation-defined manner.

### 6. What constitutes an interactive device ([5.1.2.3](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.3)).

- ä»€ä¹ˆæ„æˆäº¤äº’è®¾å¤‡ã€‚

- Not defined by GCC or LLVM themself.

- ä»…ä½œäº†è§£ç”¨ï¼šLLVMæºä»£ç ä¸­ï¼Œäº`llvm\lib\Support\Unix\Process.inc`ä¸­ï¼Œæœ‰ï¼š

  - ```c
    bool Process::FileDescriptorIsDisplayed(int fd) {
    #if HAVE_ISATTY
      return isatty(fd);
    #else
      // If we don't have isatty, just return false.
      return false;
    #endif
    }
    ```

  - å¯è§äº¤äº’å¼è®¾å¤‡æ˜¯ç³»ç»Ÿåº“è°ƒç”¨ `isatty`() ä¸ºå…¶è¿”å›éé›¶å€¼çš„è®¾å¤‡ã€‚

### 7. Whether a program can have more than one thread of execution in a freestanding environment ([5.1.2.4](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.4)).

- åœ¨ç‹¬ç«‹ç¯å¢ƒä¸­ï¼Œç¨‹åºæ˜¯å¦å¯ä»¥æ‹¥æœ‰å¤šä¸ªæ‰§è¡Œçº¿ç¨‹ã€‚
- Not defined by GCC or LLVM themself.

### 8. The set of signals, their semantics, and their default handling ([7.14](https://port70.net/~nsz/c/c11/n1570.html#7.14)).

- ä¿¡å·çš„é›†åˆã€å®ƒä»¬çš„è¯­ä¹‰ä»¥åŠå®ƒä»¬çš„é»˜è®¤å¤„ç†æ–¹å¼ã€‚
- Not defined by GCC or LLVM themself.

### 9. Signal values other than SIGFPE, SIGILL, and SIGSEGV that correspond to a computational exception ([7.14.1.1](https://port70.net/~nsz/c/c11/n1570.html#7.14.1.1)).

- é™¤äº† SIGFPEã€SIGILL å’Œ SIGSEGV ä¹‹å¤–ï¼Œä¸è®¡ç®—å¼‚å¸¸å¯¹åº”çš„ä¿¡å·å€¼ã€‚
- Not defined by GCC or LLVM themself.

### 10. Signals for which the equivalent of signal(sig, SIG_IGN); is executed at program startup ([7.14.1.1](https://port70.net/~nsz/c/c11/n1570.html#7.14.1.1)).

- ç¨‹åºå¯åŠ¨æ—¶æ‰§è¡Œ `signal(sig, SIG_IGN);` ç­‰æ•ˆæ“ä½œçš„ä¿¡å·ã€‚
- Not defined by GCC or LLVM themself.

### 11. The set of environment names and the method for altering the environment list used by the getenv function ([7.22.4.6](https://port70.net/~nsz/c/c11/n1570.html#7.22.4.6)).

- ç¯å¢ƒå˜é‡åçš„é›†åˆä»¥åŠç”¨äº `getenv` å‡½æ•°ä¿®æ”¹ç¯å¢ƒåˆ—è¡¨çš„æ–¹æ³•
- Not defined by GCC or LLVM themself.

### 12. The manner of execution of the string by the system function ([7.22.4.8](https://port70.net/~nsz/c/c11/n1570.html#7.22.4.8)).

- é€šè¿‡ `system` å‡½æ•°æ‰§è¡Œå­—ç¬¦ä¸²çš„æ–¹å¼ã€‚
- Not defined by GCC or LLVM themself.

## 3. Identifiers

### 1. Which additional multibyte characters may appear in identifiers and their correspondence to universal character names ([6.4.2](https://port70.net/~nsz/c/c11/n1570.html#6.4.2)).

- å“ªäº›é¢å¤–çš„å¤šå­—èŠ‚å­—ç¬¦å¯ä»¥å‡ºç°åœ¨æ ‡è¯†ç¬¦ä¸­ï¼Œä»¥åŠå®ƒä»¬ä¸é€šç”¨å­—ç¬¦åç§°çš„å¯¹åº”å…³ç³»ã€‚
- GCC accepts in identifiers exactly those extended characters that correspond to universal character names permitted by the chosen standard.(C11)

```c
#include <stdio.h>

int main(){
    int å˜é‡ =1;
    å˜é‡= å˜é‡+1;
    printf("%d\n",å˜é‡);
    return 0;
}
```

```c
//target_gcc
2

```

å¯è§ï¼Œä½¿ç”¨é€šç”¨å­—ç¬¦åæ˜¯å¯è¡Œçš„ï¼Œunicodeéƒ½èƒ½è¡¨ç¤ºï¼Œä¸ä¸€ä¸€å®éªŒäº†ã€‚

ä¸GCCä¸€è‡´ã€‚

### 2. The number of significant initial characters in an identifier ([5.2.4.1](https://port70.net/~nsz/c/c11/n1570.html#5.2.4.1), [6.4.2](https://port70.net/~nsz/c/c11/n1570.html#6.4.2)).

- æ ‡è¯†ç¬¦ä¸­æœ‰æ„ä¹‰çš„åˆå§‹å­—ç¬¦æ•°ã€‚

- å¯¹äºC11è€Œè¨€ï¼Œé™åˆ¶è¾ƒå®½æ¾,C11 å¯¹å†…éƒ¨æ ‡è¯†ç¬¦è¦æ±‚è‡³å°‘æ”¯æŒ63 ä¸ªæœ‰æ•ˆå­—ç¬¦,å¯¹å¤–éƒ¨æ ‡è¯†ç¬¦è¦æ±‚è‡³å°‘æ”¯æŒ31 ä¸ªæœ‰æ•ˆå­—ç¬¦:

  - > The implementation shall be able to translate and execute at least one program that contains at least one instance of every one of the following limits:18)
    >
    > ...
    > â€” 63 significant initial characters in an internal identifier or a macro name (each universal character name or extended source character is considered a single character)
    > â€” 31 significant initial characters in an external identifier (each universal character name specifying a short identifier of 0000FFFF or less is considered 6 characters, each universal character name specifying a short identifier of 00010000 or more is considered 10 characters, and each extended source character is considered the same number of characters as the corresponding universal character name, if any)19)
    > ...
    >
    > 18) Implementations should avoid imposing fixed translation limits whenever possible.
    > 19) See â€˜â€˜future language directionsâ€™â€™ (6.11.3).
    >
    > Â§6.11.3 **External names**
    > Â¶1 Restriction of the significance of an external name to fewer than 255 characters (considering each universal character name or extended source character as a single character) is an obsolescent feature that is a concession to existing implementations.

  - [What's the exact role of "significant characters" in C (variables)? - Stack Overflow](https://stackoverflow.com/questions/18290165/whats-the-exact-role-of-significant-characters-in-c-variables)

- è€Œå¯¹äºGCCè€Œè¨€ï¼š

  - For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.

```c
#include <stdio.h>

// å®šä¹‰ä¸¤ä¸ªæ ‡è¯†ç¬¦ï¼Œå‰63ä¸ªå­—ç¬¦ç›¸åŒï¼Œä½†ç¬¬64ä¸ªå­—ç¬¦ä¸åŒ
int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa = 10;
int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab = 20;

int main() {
    // æ‰“å°ä¸¤ä¸ªå˜é‡çš„å€¼ï¼Œä»¥éªŒè¯ç¼–è¯‘å™¨æ˜¯å¦åŒºåˆ†å®ƒä»¬
    printf("Value of variable a: %d\n", aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
    printf("Value of variable b: %d\n", aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab);

    // éªŒè¯ç¼–è¯‘å™¨æ˜¯å¦å°†ä¸¤ä¸ªå˜é‡è§†ä¸ºç›¸åŒçš„æ ‡è¯†ç¬¦
    if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa == 
        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab) {
        printf("Compiler treats both identifiers as the same.\n");
    } else {
        printf("Compiler treats both identifiers as different.\n");
    }

    return 0;
}

```

```c
//target_gcc
Value of variable a: 10
Value of variable b: 20
Compiler treats both identifiers as different.

```

```c
//target_clang
Value of variable a: 10
Value of variable b: 20
Compiler treats both identifiers as different.

```

å¯è§éƒ½çªç ´äº†63çš„é™åˆ¶ã€‚

ä¸GCCä¸€è‡´ã€‚

### 3. Whether case distinctions are significant in an identifier with external linkage (C90 6.1.2).

- C99 and C11 require that case distinctions are always significant in identifiers.
- åœ¨C11æ ‡å‡†ä¸‹ï¼Œè¿™å·²ç»ä¸æ˜¯ä¸€ä¸ªå®ç°å®šä¹‰è¡Œä¸ºã€‚

## 4. Characters

### 1. The number of bits in a byte ([3.6](https://port70.net/~nsz/c/c11/n1570.html#3.6)).

- ä¸€ä¸ªå­—èŠ‚ä¸­çš„ä½æ•°ã€‚
- Determined by ABI.

ä¸€èˆ¬è€Œè¨€å°±ä¸º8ä½ã€‚

### 2. The values of the members of the execution character set ([5.2.1](https://port70.net/~nsz/c/c11/n1570.html#5.2.1)).

- æ‰§è¡Œå­—ç¬¦é›†æˆå‘˜çš„å€¼ã€‚
- Determined by ABI.
  - ä¸è¿‡ç”±äºclangçš„æ‰§è¡Œå­—ç¬¦é›†å›ºå®šä¸ºUTF-8ï¼Œæ‰€ä»¥æœ¬è´¨è€Œè¨€æ˜¯ç¡®å®šçš„ã€‚

### 3. The unique value of the member of the execution character set produced for each of the standard alphabetic escape sequences ([5.2.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.2)).

- æ ‡å‡†å­—æ¯è¡¨è½¬ä¹‰åºåˆ—ç”Ÿæˆçš„æ‰§è¡Œå­—ç¬¦é›†æˆå‘˜çš„å”¯ä¸€å€¼ã€‚
- Determined by ABI.
  - å¯¹äºæµ‹è¯•ç¯å¢ƒè€Œè¨€:

```c
#include <stdio.h>

int main() {
    char a = '\a';
    char b = '\b';
    char f = '\f';
    char n = '\n';
    char r = '\r';
    char t = '\t';
    char v = '\v';
    printf("%d,%d,%d,%d,%d,%d,%d\n", a, b, f, n, r, t, v);

    return 0;

}
```

```c
//target_clang
7,8,12,10,13,9,11
```

```c
//target_gcc
7,8,12,10,13,9,11
```

å¯¹äºè¯¥æµ‹è¯•ç¯å¢ƒè€Œè¨€ï¼Œå¦‚ä¸‹è¡¨ï¼š

| **Escape Sequence** | **Unique Value** |
| ------------------- | ---------------- |
| \a                  | 7                |
| \b                  | 8                |
| \f                  | 12               |
| \n                  | 10               |
| \r                  | 13               |
| \t                  | 9                |
| \v                  | 11               |

### 4. The value of a char object into which has been stored any character other than a member of the basic execution character set ([6.2.5](https://port70.net/~nsz/c/c11/n1570.html#6.2.5)).

- å­˜å‚¨éåŸºæœ¬æ‰§è¡Œå­—ç¬¦é›†æˆå‘˜çš„ char å¯¹è±¡çš„å€¼
- Determined by ABI.
  - ä¸€èˆ¬è€Œè¨€ä¼šæŠ¥é”™ï¼Œå› ä¸ºè¿™äº›Unicodeå­—ç¬¦å¯èƒ½ä¼šè¶…è¿‡charç±»å‹èƒ½è¡¨ç¤ºçš„èŒƒå›´ï¼ˆ0-255ï¼‰

åœ¨æœ¬æµ‹è¯•ç¯å¢ƒä¸‹ï¼š

```c
#include <stdio.h>

int main() {
    char a = 'â‚¬';  // å°è¯•å­˜å‚¨ Unicode å­—ç¬¦ 'â‚¬' åˆ° char å¯¹è±¡ä¸­
    printf("%c", a);
}

```



```bash
$ make gcc
gcc --std=c11 ./test.c -o target_gcc
./test.c: In function â€˜mainâ€™:
./test.c:4:14: warning: multi-character character constant [-Wmultichar]
    4 |     char a = 'â‚¬';  // å°è¯•å­˜å‚¨ Unicode å­—ç¬¦ 'â‚¬' åˆ° char å¯¹è±¡ä¸­
      |              ^~~
./test.c:4:14: warning: overflow in conversion from â€˜intâ€™ to â€˜charâ€™ changes value from â€˜14844588â€™ to â€˜-84â€™ [-Woverflow]
echo //target_gcc > output_gcc
./target_gcc>>output_gcc

$ make clang
clang --std=c11 ./test.c -o target_clang
./test.c:4:14: error: character too large for enclosing character literal type
    char a = 'â‚¬';  // å°è¯•å­˜å‚¨ Unicode å­—ç¬¦ 'â‚¬' åˆ° char å¯¹è±¡ä¸­
             ^
1 error generated.
make: *** [Makefile:20: clang] Error 1
```

å”¯ä¸€ä¸åŒçš„æ˜¯ï¼Œæº¢å‡ºåGCCä¼šç»§ç»­æ‰§è¡Œï¼ŒLLVM/Clangä¼šæŠ¥é”™ã€‚

### 5. Which of signed char or unsigned char has the same range, representation, and behavior as ''plain'' char ([6.2.5](https://port70.net/~nsz/c/c11/n1570.html#6.2.5), [6.3.1.1](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.1)).

- signed char å’Œ unsigned char ä¸­å“ªä¸ªä¸â€œæ™®é€šâ€ char å…·æœ‰ç›¸åŒèŒƒå›´ã€è¡¨ç¤ºå’Œè¡Œä¸ºã€‚

- Determined by ABI.
  - å¯¹äºæœ¬æµ‹è¯•ç¯å¢ƒè€Œè¨€ï¼ŒGCCå’ŒClangå‡ä¸ºsigned charã€‚

```c
#include <stdio.h>

int main(){
    char a = -1;
    printf("%d", a);
    return 0;
}

```

```c
//target_gcc
-1
```

```c
//target_clang
-1
```



### 6. The mapping of members of the source character set (in character constants and string literals) to members of the execution character set ([6.4.4.4](https://port70.net/~nsz/c/c11/n1570.html#6.4.4.4), [5.1.1.2](https://port70.net/~nsz/c/c11/n1570.html#5.1.1.2)).

- æºå­—ç¬¦é›†ï¼ˆåœ¨å­—ç¬¦å¸¸é‡å’Œå­—ç¬¦ä¸²å­—é¢é‡ä¸­ï¼‰åˆ°æ‰§è¡Œå­—ç¬¦é›†çš„æ˜ å°„ã€‚
- Determined by ABI.
  - ä½†å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œclangè¦æ±‚source character setä»¥åŠexecution character setéƒ½æ˜¯UTF-8ã€‚

### 7. The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character ([6.4.4.4](https://port70.net/~nsz/c/c11/n1570.html#6.4.4.4)).

- åŒ…å«å¤šä¸ªå­—ç¬¦æˆ–åŒ…å«ä¸æ˜ å°„åˆ°å•å­—èŠ‚æ‰§è¡Œå­—ç¬¦çš„å­—ç¬¦æˆ–è½¬ä¹‰åºåˆ—çš„æ•´æ•°å­—ç¬¦å¸¸é‡çš„å€¼ã€‚

```c
#include <stdio.h>

int main(int argc, char *argv[]){
    int a = 'AB';

    printf("%d", a);
    
    return 0;
}

```

```c
//target_gcc
16706
```

```c
//target_clang
16706
```



```c
#include <stdio.h>

int main(int argc, char *argv[]){
    int a = 'ğŸ˜Š';

    printf("%d", a);

    return 0;
}

```

```bash
$ make test
gcc --std=c11 ./test.c -o target_gcc
./test.c: In function â€˜mainâ€™:
./test.c:4:13: warning: multi-character character constant [-Wmultichar]
    4 |     int a = 'ğŸ˜Š';
      |             ^~~~
echo //target_gcc > output_gcc
./target_gcc>>output_gcc
clang --std=c11 ./test.c -o target_clang
./test.c:4:13: error: character too large for enclosing character literal type
    int a = 'ğŸ˜Š';
            ^
1 error generated.
make: *** [Makefile:20: clang] Error 1
```

```c
//target_gcc
-257976182
```

äºŒç§ç±»å‹çš„å®éªŒå¦‚ä¸Šï¼Œå¯è§å¯¹äºLLVMè€Œè¨€ï¼š

1. containing more than one characterï¼šå…¶æ•´æ•°å€¼ä¸ºä»å·¦åˆ°å³æ¯ä¸ªcharä¾æ¬¡å·¦ç§»8ä½ï¼Œå¹¶ç›¸åŠ å¾—å‡ºçš„å€¼
2. containing a character or escape sequence that does not map to a single-byte execution characterï¼šç›´æ¥æŠ¥é”™

ä¸GCCä¸ä¸€è‡´ï¼ŒGCCä¼šå¼ºè¡Œè½¬æ¢å¹¶æº¢å‡ºã€‚

### 8. The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set ([6.4.4.4](https://port70.net/~nsz/c/c11/n1570.html#6.4.4.4)).

- åŒ…å«å¤šä¸ªå¤šå­—èŠ‚å­—ç¬¦æˆ–å•ä¸ªå¤šå­—èŠ‚å­—ç¬¦ï¼ˆæ˜ å°„åˆ°æ‰©å±•æ‰§è¡Œå­—ç¬¦é›†å¤šä¸ªæˆå‘˜ï¼‰æˆ–åŒ…å«ä¸åœ¨æ‰©å±•æ‰§è¡Œå­—ç¬¦é›†è¡¨ç¤ºèŒƒå›´å†…çš„å¤šå­—èŠ‚å­—ç¬¦æˆ–è½¬ä¹‰åºåˆ—çš„å®½å­—ç¬¦å¸¸é‡çš„å€¼ã€‚

```c
#include <stdio.h>
#include <wchar.h>

int main() {
    // 1. æ­£å¸¸çš„å®½å­—ç¬¦å¸¸é‡
    wchar_t valid_char = L'A';  // å•å­—ç¬¦

    // 2. åŒ…å«å¤šä¸ªå­—ç¬¦çš„å®½å­—ç¬¦å¸¸é‡ï¼ˆå¤šå­—èŠ‚å­—ç¬¦ï¼‰
    wchar_t invalid_multi_char = L'ABCD';  // ç†è®ºä¸Šæœªå®šä¹‰è¡Œä¸º

    // 3. ä½¿ç”¨Unicodeå­—ç¬¦çš„å®½å­—ç¬¦å¸¸é‡ï¼ˆUTF-8å¯èƒ½ç”¨å¤šå­—èŠ‚è¡¨ç¤ºï¼‰
    wchar_t unicode_char = L'ä¸­';  // æ­£å¸¸çš„Unicodeå­—ç¬¦

    // 4. å°è¯•ä½¿ç”¨è½¬ä¹‰åºåˆ—ï¼Œä½†è¯¥è½¬ä¹‰åºåˆ—å¯èƒ½ä¸åœ¨æ‰©å±•æ‰§è¡Œå­—ç¬¦é›†ä¸­
    wchar_t invalid_escape_char = L'\xFF';  // è¶…å‡ºèŒƒå›´çš„è½¬ä¹‰å­—ç¬¦ï¼Œå¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸º

    // æ‰“å°è¾“å‡º
    wprintf(L"Valid wchar_t: %lc\n", valid_char);
    wprintf(L"Invalid multi wchar_t (multiple characters): %lc\n", invalid_multi_char);
    wprintf(L"Unicode wchar_t: %lc\n", unicode_char);
    wprintf(L"Invalid escape wchar_t: %lc\n", invalid_escape_char);

    return 0;
}

```

```c
//target_gcc
Valid wchar_t: A
Invalid multi wchar_t (multiple characters): D
Unicode wchar_t: ?
Invalid escape wchar_t: ?

```

å¯è§åœ¨æœ¬æµ‹è¯•ç¯å¢ƒä¸­ï¼Œå¯¹äºGCCè€Œè¨€:

- æ ‡å‡†çš„å®½å­—ç¬¦å¸¸é‡ï¼ŒGCC èƒ½å¤Ÿæ­£ç¡®å¤„ç†å¹¶è¾“å‡ºã€‚
- å¤šä¸ªå­—ç¬¦çš„å®½å­—ç¬¦å¸¸é‡ï¼ŒGCCåªå–äº†å®½å­—ç¬¦å¸¸é‡ä¸­æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶å°†å…¶ä½œä¸ºå®½å­—ç¬¦å¤„ç†ã€‚
- åœ¨æ²¡æœ‰è®¾ç½®åŒºåŸŸï¼ˆlocaleï¼‰çš„æƒ…å†µä¸‹ï¼ŒGCC å¯èƒ½æ— æ³•æ­£ç¡®å¤„ç†å¹¶æ˜¾ç¤º Unicode å­—ç¬¦ã€‚
- GCC å¯¹äºè¶…å‡ºèŒƒå›´çš„è½¬ä¹‰å­—ç¬¦ æœªè¿›è¡Œç‰¹æ®Šå¤„ç†ï¼Œåªæ˜¯ç®€å•åœ°å°†å…¶è½¬æ¢ä¸ºæœªçŸ¥å­—ç¬¦ã€‚

å¯¹äºLLVMè€Œè¨€ï¼š
```bash
$ make clang
clang --std=c11 ./test.c -o target_clang
./test.c:9:34: error: wide character literals may not contain multiple characters
    wchar_t invalid_multi_char = L'ABCD';  // ç†è®ºä¸Šæœªå®šä¹‰è¡Œä¸º
                                 ^
1 error generated.
make: *** [Makefile:20: clang] Error 1
```

```c
#include <stdio.h>
#include <wchar.h>

int main() {
    // 1. æ­£å¸¸çš„å®½å­—ç¬¦å¸¸é‡
    wchar_t valid_char = L'A';  // å•å­—ç¬¦

    // 2. åŒ…å«å¤šä¸ªå­—ç¬¦çš„å®½å­—ç¬¦å¸¸é‡ï¼ˆå¤šå­—èŠ‚å­—ç¬¦ï¼‰
    //wchar_t invalid_multi_char = L'ABCD';  // ç†è®ºä¸Šæœªå®šä¹‰è¡Œä¸º

    // 3. ä½¿ç”¨Unicodeå­—ç¬¦çš„å®½å­—ç¬¦å¸¸é‡ï¼ˆUTF-8å¯èƒ½ç”¨å¤šå­—èŠ‚è¡¨ç¤ºï¼‰
    wchar_t unicode_char = L'ä¸­';  // æ­£å¸¸çš„Unicodeå­—ç¬¦

    // 4. å°è¯•ä½¿ç”¨è½¬ä¹‰åºåˆ—ï¼Œä½†è¯¥è½¬ä¹‰åºåˆ—å¯èƒ½ä¸åœ¨æ‰©å±•æ‰§è¡Œå­—ç¬¦é›†ä¸­
    wchar_t invalid_escape_char = L'\xFF';  // è¶…å‡ºèŒƒå›´çš„è½¬ä¹‰å­—ç¬¦ï¼Œå¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸º

    // æ‰“å°è¾“å‡º
    wprintf(L"Valid wchar_t: %lc\n", valid_char);
    //wprintf(L"Invalid multi wchar_t (multiple characters): %lc\n", invalid_multi_char);
    wprintf(L"Unicode wchar_t: %lc\n", unicode_char);
    wprintf(L"Invalid escape wchar_t: %lc\n", invalid_escape_char);

    return 0;
}

```

```c
//target_clang
Valid wchar_t: A
Unicode wchar_t: ?
Invalid escape wchar_t: ?

```

å¯è§åœ¨æœ¬æµ‹è¯•ç¯å¢ƒä¸­ï¼Œå¯¹äºLLVMè€Œè¨€:

- æ ‡å‡†çš„å®½å­—ç¬¦å¸¸é‡ï¼ŒLLVMèƒ½å¤Ÿæ­£ç¡®å¤„ç†å¹¶è¾“å‡ºã€‚
- å¤šä¸ªå­—ç¬¦çš„å®½å­—ç¬¦å¸¸é‡ï¼ŒLLVMä¼šç›´æ¥æŠ¥é”™ã€‚
- åœ¨æ²¡æœ‰è®¾ç½®åŒºåŸŸï¼ˆlocaleï¼‰çš„æƒ…å†µä¸‹ï¼ŒLLVMå¯èƒ½æ— æ³•æ­£ç¡®å¤„ç†å¹¶æ˜¾ç¤º Unicode å­—ç¬¦ã€‚
- LLVMå¯¹äºè¶…å‡ºèŒƒå›´çš„è½¬ä¹‰å­—ç¬¦ æœªè¿›è¡Œç‰¹æ®Šå¤„ç†ï¼Œåªæ˜¯ç®€å•åœ°å°†å…¶è½¬æ¢ä¸ºæœªçŸ¥å­—ç¬¦ã€‚

ç»¼ä¸Šï¼Œä¸GCCä¸ä¸€è‡´ã€‚å¯¹äºå¤šä¸ªå­—ç¬¦çš„å®½å­—ç¬¦å¸¸é‡è€Œè¨€ï¼ŒGCCä¼šåªå–äº†å®½å­—ç¬¦å¸¸é‡ä¸­æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶å°†å…¶ä½œä¸ºå®½å­—ç¬¦å¤„ç†ã€‚LLVMä¼šç›´æ¥æŠ¥é”™ã€‚

### 9. The current locale used to convert a wide character constant consisting of a single multibyte character that maps to a member of the extended execution character set into a corresponding wide character code ([6.4.4.4](https://port70.net/~nsz/c/c11/n1570.html#6.4.4.4)).

- å°†ç”±å½“å‰åŒºåŸŸè®¾ç½®ç”¨æ¥å°†ç”±å•ä¸ªå¤šå­—èŠ‚å­—ç¬¦ç»„æˆçš„å®½å­—ç¬¦å¸¸é‡è½¬æ¢ä¸ºç›¸åº”çš„å®½å­—ç¬¦ä»£ç çš„å½“å‰åŒºåŸŸè®¾ç½®ã€‚

```c
#include <stdio.h>
#include <locale.h>
#include <wchar.h>

int main() {
    // è®¾ç½®å¹¶æ‰“å°åˆå§‹åŒºåŸŸ
    wprintf(L"Default locale: %s\n", setlocale(LC_ALL, NULL));

    // å°è¯•åœ¨é»˜è®¤åŒºåŸŸä¸‹å¤„ç†å¤šå­—èŠ‚ä¸­æ–‡å­—ç¬¦ 'ä¸­'
    wchar_t mb_char = L'ä¸­';  // ä½¿ç”¨ä¸­æ–‡å­—ç¬¦ 'ä¸­'
    wprintf(L"Wide char in default locale: %lc (code: %d)\n", mb_char, mb_char);

    // è®¾ç½®åŒºåŸŸä¸º "C" åŒºåŸŸ
    setlocale(LC_ALL, "C");
    wprintf(L"\nLocale set to C: %s\n", setlocale(LC_ALL, NULL));
    wprintf(L"Wide char in C locale: %lc (code: %d)\n", mb_char, mb_char);

    // è®¾ç½®åŒºåŸŸä¸º "en_US.UTF-8"
    setlocale(LC_ALL, "en_US.UTF-8");
    wprintf(L"\nLocale set to en_US.UTF-8: %s\n", setlocale(LC_ALL, NULL));
    wprintf(L"Wide char in en_US.UTF-8 locale: %lc (code: %d)\n", mb_char, mb_char);

    // è®¾ç½®åŒºåŸŸä¸º "zh_CN.UTF-8"
    setlocale(LC_ALL, "zh_CN.UTF-8");
    wprintf(L"\nLocale set to zh_CN.UTF-8: %s\n", setlocale(LC_ALL, NULL));
    wprintf(L"Wide char in zh_CN.UTF-8 locale: %lc (code: %d)\n", mb_char, mb_char);

    return 0;
}

```

```c
//target_gcc
Default locale: C
Wide char in default locale: ? (code: 20013)

Locale set to C: C
Wide char in C locale: ? (code: 20013)

Locale set to en_US.UTF-8: en_US.UTF-8
Wide char in en_US.UTF-8 locale: ? (code: 20013)

Locale set to zh_CN.UTF-8: zh_CN.UTF-8
Wide char in zh_CN.UTF-8 locale: ? (code: 20013)

```

```c
//target_clang
Default locale: C
Wide char in default locale: ? (code: 20013)

Locale set to C: C
Wide char in C locale: ? (code: 20013)

Locale set to en_US.UTF-8: en_US.UTF-8
Wide char in en_US.UTF-8 locale: ? (code: 20013)

Locale set to zh_CN.UTF-8: zh_CN.UTF-8
Wide char in zh_CN.UTF-8 locale: ? (code: 20013)

```



ä¸GCCä¸€è‡´ã€‚åœ¨ `C` åŒºåŸŸä¸­ï¼Œä¸­æ–‡å­—ç¬¦æ— æ³•æ­£ç¡®æ˜¾ç¤ºï¼Œè€Œåœ¨æ”¯æŒ UTF-8 çš„åŒºåŸŸï¼ˆå¦‚ `en_US.UTF-8` å’Œ `zh_CN.UTF-8`ï¼‰ï¼Œå­—ç¬¦å¯ä»¥æ­£ç¡®å­˜å‚¨ï¼Œä½†ç»ˆç«¯æ˜¯å¦èƒ½æ­£ç¡®æ˜¾ç¤ºåˆ™å–å†³äºç»ˆç«¯çš„å­—ä½“å’Œç¼–ç æ”¯æŒæƒ…å†µã€‚

### 10. Whether differently-prefixed wide string literal tokens can be concatenated and, if so, the treatment of the resulting multibyte character sequence ([6.4.5](https://port70.net/~nsz/c/c11/n1570.html#6.4.5)).

- ä¸åŒå‰ç¼€çš„å®½å­—ç¬¦ä¸²å­—é¢é‡æ˜¯å¦å¯ä»¥è¿æ¥ï¼Œå¦‚æœå¯ä»¥ï¼Œç”Ÿæˆçš„å¤šå­—èŠ‚å­—ç¬¦åºåˆ—çš„å¤„ç†æ–¹å¼ã€‚

```c
#include <wchar.h>

int main() {
    // ä¸‹é¢è¿™äº›æ“ä½œå°†äº§ç”Ÿç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºä¸åŒå‰ç¼€çš„å­—ç¬¦ä¸²å­—é¢é‡ä¸èƒ½æ‹¼æ¥
    wchar_t *str1 = L"Hello" L" World";   // åŒå‰ç¼€å¯ä»¥æ‹¼æ¥ï¼Œä½†ä¸ºäº†ä¿æŒä¸€è‡´æ€§ä¿ç•™
    wchar_t *str2 = L"Hello" u" World";   // L å’Œ u å‰ç¼€çš„æ‹¼æ¥
    wchar_t *str3 = L"Hello" U" World";   // L å’Œ U å‰ç¼€çš„æ‹¼æ¥
    wchar_t *str4 = L"Hello" u8" World";  // L å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
    char16_t *str5 = u"Hello" u8" World"; // u å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
    char32_t *str6 = U"Hello" L" World";  // U å’Œ L å‰ç¼€çš„æ‹¼æ¥
    char *str7 = u8"Hello" U" World";     // u8 å’Œ U å‰ç¼€çš„æ‹¼æ¥
    
    // æ‰“å°ç»“æœä»¥é˜²æ­¢ç¼–è¯‘å™¨å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡
    // ï¼ˆå°½ç®¡ä¸Šé¢çš„ä»£ç åº”è¯¥åœ¨ç¼–è¯‘é˜¶æ®µå°±ä¼šæŠ¥é”™ï¼‰
    wprintf(L"%ls\n", str1);
    wprintf(L"%ls\n", str2);
    wprintf(L"%ls\n", str3);
    wprintf(L"%ls\n", str4);
    wprintf(L"%ls\n", str5);
    wprintf(L"%ls\n", str6);
    printf("%s\n", str7);

    return 0;
}

```

```bash
$ make gcc
gcc --std=c11 ./test.c -o target_gcc
./test.c: In function â€˜mainâ€™:
./test.c:6:5: error: unsupported non-standard concatenation of string literals
    6 |     wchar_t *str2 = L"Hello" u" World";   // L å’Œ u å‰ç¼€çš„æ‹¼æ¥
      |     ^~~~~~~
./test.c:6:5: error: unsupported non-standard concatenation of string literals
./test.c:7:5: error: unsupported non-standard concatenation of string literals
    7 |     wchar_t *str3 = L"Hello" U" World";   // L å’Œ U å‰ç¼€çš„æ‹¼æ¥
      |     ^~~~~~~
./test.c:7:5: error: unsupported non-standard concatenation of string literals
./test.c:8:5: error: unsupported non-standard concatenation of string literals
    8 |     wchar_t *str4 = L"Hello" u8" World";  // L å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
      |     ^~~~~~~
./test.c:8:5: error: unsupported non-standard concatenation of string literals
./test.c:9:5: error: unknown type name â€˜char16_tâ€™
    9 |     char16_t *str5 = u"Hello" u8" World"; // u å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
      |     ^~~~~~~~
./test.c:9:5: error: unsupported non-standard concatenation of string literals
./test.c:9:5: error: unsupported non-standard concatenation of string literals
./test.c:9:22: warning: initialization of â€˜int *â€™ from incompatible pointer type â€˜short unsigned int *â€™ [-Wincompatible-pointer-types]
    9 |     char16_t *str5 = u"Hello" u8" World"; // u å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
      |                      ^~~~~~~~
./test.c:10:5: error: unknown type name â€˜char32_tâ€™
   10 |     char32_t *str6 = U"Hello" L" World";  // U å’Œ L å‰ç¼€çš„æ‹¼æ¥
      |     ^~~~~~~~
./test.c:10:5: error: unsupported non-standard concatenation of string literals
./test.c:10:5: error: unsupported non-standard concatenation of string literals
./test.c:11:5: error: unsupported non-standard concatenation of string literals
   11 |     char *str7 = u8"Hello" U" World";     // u8 å’Œ U å‰ç¼€çš„æ‹¼æ¥
      |     ^~~~
./test.c:11:5: error: unsupported non-standard concatenation of string literals
./test.c:21:5: warning: implicit declaration of function â€˜printfâ€™ [-Wimplicit-function-declaration]
   21 |     printf("%s\n", str7);
      |     ^~~~~~
./test.c:2:1: note: include â€˜<stdio.h>â€™ or provide a declaration of â€˜printfâ€™
    1 | #include <wchar.h>
  +++ |+#include <stdio.h>
    2 |
./test.c:21:5: warning: incompatible implicit declaration of built-in function â€˜printfâ€™ [-Wbuiltin-declaration-mismatch]
   21 |     printf("%s\n", str7);
      |     ^~~~~~
./test.c:21:5: note: include â€˜<stdio.h>â€™ or provide a declaration of â€˜printfâ€™
make: *** [Makefile:15: gcc] Error 1
```

```c
make clang
clang --std=c11 ./test.c -o target_clang
./test.c:6:30: error: unsupported non-standard concatenation of string literals
    wchar_t *str2 = L"Hello" u" World";   // L å’Œ u å‰ç¼€çš„æ‹¼æ¥
                             ^
./test.c:7:30: error: unsupported non-standard concatenation of string literals
    wchar_t *str3 = L"Hello" U" World";   // L å’Œ U å‰ç¼€çš„æ‹¼æ¥
                             ^
./test.c:8:30: error: unsupported non-standard concatenation of string literals
    wchar_t *str4 = L"Hello" u8" World";  // L å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
                             ^
./test.c:9:5: error: use of undeclared identifier 'char16_t'
    char16_t *str5 = u"Hello" u8" World"; // u å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
    ^
./test.c:9:15: error: use of undeclared identifier 'str5'
    char16_t *str5 = u"Hello" u8" World"; // u å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
              ^
./test.c:9:31: error: unsupported non-standard concatenation of string literals
    char16_t *str5 = u"Hello" u8" World"; // u å’Œ u8 å‰ç¼€çš„æ‹¼æ¥
                              ^
./test.c:10:5: error: use of undeclared identifier 'char32_t'
    char32_t *str6 = U"Hello" L" World";  // U å’Œ L å‰ç¼€çš„æ‹¼æ¥
    ^
./test.c:10:15: error: use of undeclared identifier 'str6'
    char32_t *str6 = U"Hello" L" World";  // U å’Œ L å‰ç¼€çš„æ‹¼æ¥
              ^
./test.c:10:31: error: unsupported non-standard concatenation of string literals
    char32_t *str6 = U"Hello" L" World";  // U å’Œ L å‰ç¼€çš„æ‹¼æ¥
                              ^
./test.c:11:28: error: unsupported non-standard concatenation of string literals
    char *str7 = u8"Hello" U" World";     // u8 å’Œ U å‰ç¼€çš„æ‹¼æ¥
                           ^
./test.c:19:23: error: use of undeclared identifier 'str5'
    wprintf(L"%ls\n", str5);
                      ^
./test.c:20:23: error: use of undeclared identifier 'str6'
    wprintf(L"%ls\n", str6);
                      ^
./test.c:21:5: warning: implicitly declaring library function 'printf' with type 'int (const char *, ...)' [-Wimplicit-function-declaration]
    printf("%s\n", str7);
    ^
./test.c:21:5: note: include the header <stdio.h> or explicitly provide a declaration for 'printf'
1 warning and 12 errors generated.
make: *** [Makefile:20: clang] Error 1
```

éƒ½ä¸å…è®¸è¿æ¥ã€‚

ä¸GCCä¸€è‡´ã€‚

### 11. The current locale used to convert a wide string literal into corresponding wide character codes ([6.4.5](https://port70.net/~nsz/c/c11/n1570.html#6.4.5)).

- å°†å®½å­—ç¬¦ä¸²å­—é¢é‡è½¬æ¢ä¸ºç›¸åº”çš„å®½å­—ç¬¦ä»£ç çš„å½“å‰åŒºåŸŸè®¾ç½®ã€‚

```c
#include <stdio.h>
#include <locale.h>
#include <wchar.h>

int main() {
    // è®¾ç½®å¹¶æ‰“å°åˆå§‹åŒºåŸŸ
    wprintf(L"Default locale: %s\n", setlocale(LC_ALL, NULL));

    // å°è¯•åœ¨é»˜è®¤åŒºåŸŸä¸‹å¤„ç†å¤šå­—èŠ‚ä¸­æ–‡å­—ç¬¦ 'ä¸­'
    wchar_t *wstr_zh = L"Hello ä¸–ç•Œ";
    wprintf(L"Wide char in default locale: %ls (code: %d)\n", wstr_zh, wstr_zh);

    // è®¾ç½®åŒºåŸŸä¸º "C" åŒºåŸŸ
    setlocale(LC_ALL, "C");
    wprintf(L"\nLocale set to C: %s\n", setlocale(LC_ALL, NULL));
    wprintf(L"Wide char in C locale: %ls (code: %d)\n", wstr_zh, wstr_zh);

    // è®¾ç½®åŒºåŸŸä¸º "en_US.UTF-8"
    setlocale(LC_ALL, "en_US.UTF-8");
    wprintf(L"\nLocale set to en_US.UTF-8: %s\n", setlocale(LC_ALL, NULL));
    wprintf(L"Wide char in en_US.UTF-8 locale: %ls (code: %d)\n", wstr_zh, wstr_zh);

    // è®¾ç½®åŒºåŸŸä¸º "zh_CN.UTF-8"
    setlocale(LC_ALL, "zh_CN.UTF-8");
    wprintf(L"\nLocale set to zh_CN.UTF-8: %s\n", setlocale(LC_ALL, NULL));
    wprintf(L"Wide char in zh_CN.UTF-8 locale: %ls (code: %d)\n", wstr_zh, wstr_zh);

    return 0;
}

```

```c
//target_gcc
Default locale: C
Wide char in default locale: Hello ?? (code: -18620328)

Locale set to C: C
Wide char in C locale: Hello ?? (code: -18620328)

Locale set to en_US.UTF-8: en_US.UTF-8
Wide char in en_US.UTF-8 locale: Hello ?? (code: -18620328)

Locale set to zh_CN.UTF-8: zh_CN.UTF-8
Wide char in zh_CN.UTF-8 locale: Hello ?? (code: -18620328)

```

```c
//target_clang
Default locale: C
Wide char in default locale: Hello ?? (code: -1209982892)

Locale set to C: C
Wide char in C locale: Hello ?? (code: -1209982892)

Locale set to en_US.UTF-8: en_US.UTF-8
Wide char in en_US.UTF-8 locale: Hello ?? (code: -1209982892)

Locale set to zh_CN.UTF-8: zh_CN.UTF-8
Wide char in zh_CN.UTF-8 locale: Hello ?? (code: -1209982892)

```

ä¸GCCå¤§è‡´ç›¸åŒï¼Œä½†æœ‰æ‰€ä¸åŒï¼š

GCCå’ŒLLVMçš„å¤„ç†æ–¹å¼åŸºæœ¬ä¸€è‡´ï¼Œåœ¨åŒºåŸŸè®¾ç½®ä¸åŒçš„æƒ…å†µä¸‹ï¼Œå®½å­—ç¬¦å­—é¢é‡çš„è½¬æ¢æ²¡æœ‰å—åˆ°å½±å“ï¼Œå­—ç¬¦ä¾æ—§æ— æ³•æ­£ç¡®æ˜¾ç¤ºï¼Œè¿™è¯´æ˜ä¸¤ä¸ªç¼–è¯‘å™¨éƒ½ä¸ä¾èµ–åŒºåŸŸè®¾ç½®æ¥å†³å®šå®½å­—ç¬¦å­—é¢é‡çš„å†…éƒ¨è¡¨ç¤ºã€‚åœ¨æœ¬å®éªŒç¯å¢ƒä¸­ï¼Œå³ä½¿åŒºåŸŸè®¾ç½®æˆåŠŸæ”¹å˜ï¼Œå®½å­—ç¬¦çš„æ˜¾ç¤ºç»“æœå’Œç¼–ç å€¼ä»ç„¶æ²¡æœ‰å˜åŒ–ã€‚è™½ç„¶æœ€ç»ˆæ˜¾ç¤ºç»“æœç›¸åŒï¼Œä½†GCCå’ŒLLVMåœ¨å¤„ç†å®½å­—ç¬¦çš„ç¼–ç å€¼ä¸Šå­˜åœ¨ä¸åŒçš„è¡¨ç°ï¼Œè¿™è¡¨æ˜å®ƒä»¬çš„å®½å­—ç¬¦å­—é¢é‡å¤„ç†æœºåˆ¶æœ‰æ‰€å·®å¼‚ã€‚

### 12. The value of a string literal containing a multibyte character or escape sequence not represented in the execution character set ([6.4.5](https://port70.net/~nsz/c/c11/n1570.html#6.4.5)).

- åŒ…å«ä¸åœ¨æ‰§è¡Œå­—ç¬¦é›†è¡¨ç¤ºèŒƒå›´å†…çš„å¤šå­—èŠ‚å­—ç¬¦æˆ–è½¬ä¹‰åºåˆ—çš„å­—ç¬¦ä¸²å­—é¢é‡çš„å€¼ã€‚

```c
#include <stdio.h>
#include <string.h>

int main() {
    // åŒ…å«å¤šå­—èŠ‚å­—ç¬¦çš„å­—ç¬¦ä¸²å­—é¢é‡ï¼ˆä¸­æ–‡å­—ç¬¦å’Œå…¶ä»–å­—ç¬¦ï¼‰
    char *str1 = "Hello ä¸–ç•Œ";        // UTF-8 å­—ç¬¦
    char *str2 = "\xFFHello";         // è½¬ä¹‰åºåˆ—ï¼Œ\xFF åœ¨ä¸åŒå­—ç¬¦é›†ä¸‹å¯èƒ½è¡¨ç°ä¸åŒ
    char *str3 = "\u4E16\u754C";      // Unicode è½¬ä¹‰å­—ç¬¦ï¼ˆä¸–ç•Œï¼‰

    // æ‰“å°å­—ç¬¦ä¸²å¹¶æ˜¾ç¤ºé•¿åº¦
    printf("str1 (multibyte characters): %s\n", str1);
    printf("Length of str1: %zu\n", strlen(str1));

    printf("str2 (escape sequence \\xFF): %s\n", str2);
    printf("Length of str2: %zu\n", strlen(str2));

    // å°è¯•æ‰“å°åŒ…å«Unicodeè½¬ä¹‰çš„å­—ç¬¦ä¸²
    printf("str3 (Unicode escape \\u4E16\\u754C): %s\n", str3);
    printf("Length of str3: %zu\n", strlen(str3));

    // æ‰“å°å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦çš„å…·ä½“å€¼ï¼ˆASCIIæˆ–å¤šå­—èŠ‚è¡¨ç¤ºï¼‰
    printf("Character values in str1:\n");
    for (size_t i = 0; i < strlen(str1); i++) {
        printf("0x%02X ", (unsigned char)str1[i]);
    }
    printf("\n");

    printf("Character values in str2:\n");
    for (size_t i = 0; i < strlen(str2); i++) {
        printf("0x%02X ", (unsigned char)str2[i]);
    }
    printf("\n");

    return 0;
}

```

GCCå’ŒClangéƒ½èƒ½å¤Ÿæ­£ç¡®å¤„ç†UTF-8å¤šå­—èŠ‚å­—ç¬¦ï¼Œæ— è®ºæ˜¯ç›´æ¥å†™å…¥å­—ç¬¦ä¸²è¿˜æ˜¯é€šè¿‡Unicodeè½¬ä¹‰åºåˆ—ï¼Œè¿™è¡¨æ˜å®ƒä»¬çš„å­—ç¬¦å¤„ç†æœºåˆ¶åœ¨è¿™æ–¹é¢æ˜¯ä¸€è‡´çš„ã€‚

ä¸¤ç§ç¼–è¯‘å™¨éƒ½å°†`\xFF`è¯†åˆ«ä¸ºä¸å¯æ‰“å°å­—ç¬¦ï¼Œå¹¶æ˜¾ç¤ºä¸º`ï¿½`ï¼Œè¿™ç¬¦åˆé¢„æœŸï¼Œè¡¨æ˜`\xFF`åœ¨å½“å‰æ‰§è¡Œå­—ç¬¦é›†ï¼ˆUTF-8ï¼‰ä¸­æ˜¯æ— æ•ˆå­—ç¬¦ã€‚

ä¸GCCéƒ¨åˆ†ä¸€è‡´ã€‚

### 13. The encoding of any of wchar_t, char16_t, and char32_t where the corresponding standard encoding macro (__STDC_ISO_10646__, __STDC_UTF_16__, or __STDC_UTF_32__) is not defined ([6.10.8.2](https://port70.net/~nsz/c/c11/n1570.html#6.10.8.2)).

```c
#include <stdio.h>
#include <wchar.h>
#include <uchar.h>

#undef __STDC_ISO_10646__
#undef __STDC_UTF_16__
#undef __STDC_UTF_32__


int main() {
    printf("Checking encoding macros:\n");

    #ifdef __STDC_ISO_10646__
        printf("__STDC_ISO_10646__ is defined: wchar_t uses ISO 10646 encoding\n");
    #else
        printf("__STDC_ISO_10646__ is not defined: wchar_t encoding is not ISO 10646\n");
    #endif

    #ifdef __STDC_UTF_16__
        printf("__STDC_UTF_16__ is defined: char16_t uses UTF-16 encoding\n");
    #else
        printf("__STDC_UTF_16__ is not defined: char16_t encoding is not UTF-16\n");
    #endif

    #ifdef __STDC_UTF_32__
        printf("__STDC_UTF_32__ is defined: char32_t uses UTF-32 encoding\n");
    #else
        printf("__STDC_UTF_32__ is not defined: char32_t encoding is not UTF-32\n");
    #endif

    wchar_t wc = L'ç‹';
    wprintf(L"wchar_t: %lc\n", wc);

    char16_t c16 = u'ç‹';
    wprintf(L"char16_t: %u\n", (unsigned int)c16);

    char32_t c32 = U'ç‹';
    wprintf(L"char32_t: %u\n", (unsigned int)c32);

    return 0;
}

```

```c
//target_gcc
Checking encoding macros:
__STDC_ISO_10646__ is not defined: wchar_t encoding is not ISO 10646
__STDC_UTF_16__ is not defined: char16_t encoding is not UTF-16
__STDC_UTF_32__ is not defined: char32_t encoding is not UTF-32
wchar_t: ?
char16_t: 29579
char32_t: 29579
```

```c
//target_clang
Checking encoding macros:
__STDC_ISO_10646__ is not defined: wchar_t encoding is not ISO 10646
__STDC_UTF_16__ is not defined: char16_t encoding is not UTF-16
__STDC_UTF_32__ is not defined: char32_t encoding is not UTF-32
wchar_t: ?
char16_t: 29579
char32_t: 29579
```

ç»å®éªŒï¼ŒGCCå’ŒLLVMè¡Œä¸ºä¸€è‡´ã€‚

## 5. Integers

### 1. Any extended integer types that exist in the implementation ([6.2.5](https://port70.net/~nsz/c/c11/n1570.html#6.2.5)).

- å®ç°ä¸­å­˜åœ¨çš„ä»»ä½•æ‰©å±•æ•´æ•°ç±»å‹ã€‚
- å°½ç®¡GCCå®ç°ä¸­å­˜åœ¨åƒ `__int128` è¿™æ ·çš„éæ ‡å‡†æ‰©å±•ç±»å‹ï¼Œè¿™äº›ç±»å‹åœ¨æŠ€æœ¯ä¸Šæ˜¯GCCçš„æ‰©å±•ç‰¹æ€§ï¼Œä½†æ ¹æ®æ–‡æ¡£æ‰€è¿°ï¼ŒGCCå¹¶æ²¡æœ‰åœ¨æ ‡å‡†æ„ä¹‰ä¸Šï¼ˆC99å’ŒC11çš„6.2.5èŠ‚å®šä¹‰çš„ä¸Šä¸‹æ–‡ä¸­ï¼‰æ”¯æŒä»»ä½•â€œæ‰©å±•æ•´æ•°ç±»å‹â€ã€‚

> **GCC Extension for 128-bit Integers** GCC provides a set of nonstandard integer types as an extension, for example `__int128`. This type is not defined by the C or C++ standards but is supported on some platforms, offering extended precision for integer arithmetic. It is only supported on platforms that provide a `__int128` hardware or software support.

åœ¨LLVM-PROJECT/libcxx/include/stdint.hä¸­ï¼š
```c
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_STDINT_H
// AIX system headers need stdint.h to be re-enterable while _STD_TYPES_T
// is defined until an inclusion of it without _STD_TYPES_T occurs, in which
// case the header guard macro is defined.
#if !defined(_AIX) || !defined(_STD_TYPES_T)
#  define _LIBCPP_STDINT_H
#endif // _STD_TYPES_T

/*
    stdint.h synopsis

Macros:

    INT8_MIN
    INT16_MIN
    INT32_MIN
    INT64_MIN

    INT8_MAX
    INT16_MAX
    INT32_MAX
    INT64_MAX

    UINT8_MAX
    UINT16_MAX
    UINT32_MAX
    UINT64_MAX

    INT_LEAST8_MIN
    INT_LEAST16_MIN
    INT_LEAST32_MIN
    INT_LEAST64_MIN

    INT_LEAST8_MAX
    INT_LEAST16_MAX
    INT_LEAST32_MAX
    INT_LEAST64_MAX

    UINT_LEAST8_MAX
    UINT_LEAST16_MAX
    UINT_LEAST32_MAX
    UINT_LEAST64_MAX

    INT_FAST8_MIN
    INT_FAST16_MIN
    INT_FAST32_MIN
    INT_FAST64_MIN

    INT_FAST8_MAX
    INT_FAST16_MAX
    INT_FAST32_MAX
    INT_FAST64_MAX

    UINT_FAST8_MAX
    UINT_FAST16_MAX
    UINT_FAST32_MAX
    UINT_FAST64_MAX

    INTPTR_MIN
    INTPTR_MAX
    UINTPTR_MAX

    INTMAX_MIN
    INTMAX_MAX

    UINTMAX_MAX

    PTRDIFF_MIN
    PTRDIFF_MAX

    SIG_ATOMIC_MIN
    SIG_ATOMIC_MAX

    SIZE_MAX

    WCHAR_MIN
    WCHAR_MAX

    WINT_MIN
    WINT_MAX

    INT8_C(value)
    INT16_C(value)
    INT32_C(value)
    INT64_C(value)

    UINT8_C(value)
    UINT16_C(value)
    UINT32_C(value)
    UINT64_C(value)

    INTMAX_C(value)
    UINTMAX_C(value)

*/

#include <__config>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

/* C99 stdlib (e.g. glibc < 2.18) does not provide macros needed
   for C++11 unless __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS
   are defined
*/
#if defined(__cplusplus) && !defined(__STDC_LIMIT_MACROS)
#  define __STDC_LIMIT_MACROS
#endif
#if defined(__cplusplus) && !defined(__STDC_CONSTANT_MACROS)
#  define __STDC_CONSTANT_MACROS
#endif

#if __has_include_next(<stdint.h>)
#  include_next <stdint.h>
#endif

#endif // _LIBCPP_STDINT_H

```

è¯¾ä»¶LLVM è‡ªèº«å¹¶æ²¡æœ‰ç›´æ¥å®šä¹‰æˆ–æ‰©å±•å‡ºè¶…å‡ºæ ‡å‡†C/C++æ•´æ•°ç±»å‹ä»¥å¤–çš„â€œæ‰©å±•æ•´æ•°ç±»å‹â€ã€‚åœ¨ C å’Œ C++ æ ‡å‡†ä¸­ï¼Œ`stdint.h` å®šä¹‰äº†ä¸€äº›æ ‡å‡†æ•´æ•°ç±»å‹ï¼Œæ¯”å¦‚ `int8_t`ã€`int16_t`ã€`int32_t`ã€`int64_t` ä»¥åŠå®ƒä»¬çš„æ— ç¬¦å·ç‰ˆæœ¬ï¼Œé™¤æ­¤ä¹‹å¤–è¿˜æœ‰ä¸€äº›ä¸“é—¨ä¸ºæŸäº›ç‰¹å®šä½å®½è®¾è®¡çš„ç±»å‹ï¼Œæ¯”å¦‚ `int_least8_t`ã€`int_fast16_t` ç­‰ã€‚å®ƒæœ¬è´¨ä¸Šåªæ˜¯åšäº†ä¸€äº›å°è£…ï¼Œä»¥ç¡®ä¿ç³»ç»Ÿç¯å¢ƒä¸­èƒ½å¤Ÿæ­£ç¡®åŒ…å«å¹¶ä½¿ç”¨æ ‡å‡†çš„ `stdint.h`ï¼Œå¹¶ä¸”æ ¹æ®ä¸€äº›å®å’Œå¹³å°è¦æ±‚æä¾›é¢å¤–çš„å…¼å®¹æ€§å¤„ç†ã€‚

æ•…GCCä¸LLVMä¸€è‡´ï¼Œå‡æ²¡æœ‰ã€‚

### 2. Whether signed integer types are represented using sign and magnitude, two's complement, or ones' complement, and whether the extraordinary value is a trap representation or an ordinary value ([6.2.6.2](https://port70.net/~nsz/c/c11/n1570.html#6.2.6.2)).

- æœ‰ç¬¦å·æ•´æ•°ç±»å‹æ˜¯ä½¿ç”¨ç¬¦å·-æ•°å€¼è¡¨ç¤ºæ³•ã€äºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºæ³•è¿˜æ˜¯åç è¡¨ç¤ºæ³•ï¼Œä»¥åŠæ˜¯å¦æœ‰ç‰¹æ®Šå€¼æ˜¯é™·é˜±è¡¨ç¤ºæ³•æˆ–æ™®é€šå€¼ã€‚

- æ•´æ•°ç±»å‹ä½¿ç”¨äºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºæ³•

  > Because `arith` integers use a twoâ€™s complement representation, this operation is applicable on both signed and unsigned integer operands.
  >
  > ['arith' Dialect - MLIR (llvm.org)](https://mlir.llvm.org/docs/Dialects/ArithOps/)

LLVMä¸æ”¯æŒâ€œé™·é˜±è¡¨ç¤ºâ€ã€‚
å’ŒGCCä¸€è‡´ã€‚

### 3. The rank of any extended integer type relative to another extended integer type with the same precision ([6.3.1.1](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.1)).

- ä»»æ„æ‰©å±•æ•´æ•°ç±»å‹çš„çº§åˆ«ç›¸å¯¹äºå…·æœ‰ç›¸åŒç²¾åº¦çš„å¦ä¸€æ‰©å±•æ•´æ•°ç±»å‹çš„çº§åˆ«ã€‚

ç”±äºclangæ ¹æœ¬æ²¡æœ‰extended integer typesï¼Œæ‰€ä»¥è¿™ä¸ªè‡ªç„¶ä¹Ÿæ²¡æœ‰ã€‚

å’ŒGCCä¸€è‡´ã€‚

### 4. The result of, or the signal raised by, converting an integer to a signed integer type when the value cannot be represented in an object of that type ([6.3.1.3](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.3)).

- å½“ä¸€ä¸ªæ•´æ•°å€¼ä¸èƒ½ç”¨æœ‰ç¬¦å·æ•´æ•°ç±»å‹è¡¨ç¤ºæ—¶ï¼Œå°†å…¶è½¬æ¢ä¸ºè¯¥ç±»å‹çš„ç»“æœï¼Œæˆ–å¼•å‘çš„ä¿¡å·ã€‚

```c
#include <stdio.h>
#include <wchar.h>
#include <uchar.h>

int main() {
    __int8_t smallInt = 300;
    printf("smallInt: %d\n", smallInt);
    return 0;
}
```

```c
//target_gcc
smallInt: 44
```

```c
//target_clang
smallInt: 44
```

```bash
$ clang -S -emit-llvm test.c -o test_clang.ll
test.c:6:25: warning: implicit conversion from 'int' to '__int8_t' (aka 'signed char') changes value from 300 to 44 [-Wconstant-conversion]
    __int8_t smallInt = 300;
             ~~~~~~~~   ^~~
1 warning generated.
```

```c
; ModuleID = 'test.c'
source_filename = "test.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [14 x i8] c"smallInt: %d\0A\00", align 1

; Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i8, align 1
  store i32 0, i32* %1, align 4
  store i8 44, i8* %2, align 1
  %3 = load i8, i8* %2, align 1
  %4 = sext i8 %3 to i32
  %5 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i64 0, i64 0), i32 noundef %4)
  ret i32 0
}

declare i32 @printf(i8* noundef, ...) #1

attributes #0 = { noinline nounwind optnone uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 1}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{!"Ubuntu clang version 14.0.0-1ubuntu1.1"}
```

GCCï¼šFor conversion to a type of width *N*, the value is reduced modulo *2^N* to be within range of the type; no signal is raised.

åœ¨LLVMå‰ç«¯çš„ä¸­é—´ä»£ç ç”Ÿæˆé˜¶æ®µï¼Œå·²ç»è‡ªåŠ¨å¯¹300å–æ¨¡å¾—åˆ°44äº†

æ³¨æ„ï¼šè™½ç„¶[document implementation-defined behavior Â· Issue #11644 Â· llvm/llvm-project (github.com)](https://github.com/llvm/llvm-project/issues/11644)ä¸­æåŠï¼Œæ­¤å¤„GCCå’ŒLLVMè¡Œä¸ºä¸åŒï¼Œä½†ç»è¿‡å®éªŒï¼Œå‘ç°ç›¸åŒï¼Œåœ¨æœ¬å®ç°ç¯å¢ƒä¸‹å¹¶æ²¡æœ‰è¯¥issueä¸­æåˆ°çš„ç±»ä¼¼äº`%conv = trunc i32 %x to i8`çš„IRä»£ç ã€‚

ä¸GCCä¸€è‡´ã€‚

### 5. The results of some bitwise operations on signed integers ([6.5](https://port70.net/~nsz/c/c11/n1570.html#6.5)).

- å¯¹æœ‰ç¬¦å·æ•´æ•°è¿›è¡ŒæŸäº›æŒ‰ä½æ“ä½œçš„ç»“æœã€‚

- Bitwise operators act on the representation of the value including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit. Signed â€˜>>â€™ acts on negative numbers by sign extension.

  As an extension to the C language, GCC does not use the latitude given in C99 and C11 only to treat certain aspects of signed â€˜<<â€™ as undefined. However, -fsanitize=shift (and -fsanitize=undefined) will diagnose such cases. They are also diagnosed where constant expressions are required.

```c
#include <stdio.h>

int main() {
    int x = 1;
    x = x << 32;
    return 0;
}

```

`Makefile`ä¸­,ä¿®æ”¹`CFLAGS`ä¸º`CFLAGS = --std=c11 -fsanitize=shift`ã€‚

```bash
$ make gcc
gcc --std=c11 -fsanitize=shift ./test.c -o target_gcc
./test.c: In function â€˜mainâ€™:
./test.c:5:11: warning: left shift count >= width of type [-Wshift-count-overflow]
    5 |     x = x << 32;
      |           ^~
echo //target_gcc > output_gcc
./target_gcc>>output_gcc
test.c:5:11: runtime error: shift exponent 32 is too large for 32-bit type 'int'
```

```bash
$ make clang
clang --std=c11 -fsanitize=shift ./test.c -o target_clang
./test.c:5:11: warning: shift count >= width of type [-Wshift-count-overflow]
    x = x << 32;
          ^  ~~
1 warning generated.
echo //target_clang > output_clang
./target_clang>>output_clang
test.c:5:11: runtime error: shift exponent 32 is too large for 32-bit type 'int'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior test.c:5:11 in
```

LLVMä¸GCCä¸€æ ·ï¼Œåªæœ‰å·¦ç§»ä¼šå‡ºé—®é¢˜ï¼ˆå…¶ä»–å·¦ç§»ä¼šå‡ºé—®é¢˜çš„ä¾‹å­æˆ‘ä¸å…¨æ”¾äº†ï¼‰ã€‚

å¦‚æœåŠ ä¸Š-fsanitize=shiftä¼šæ£€æµ‹å¹¶æŠ¥å‘Šé—®é¢˜ï¼Œå¦åˆ™è®¤å®šä¸ºæ— å¼‚å¸¸æ­£å¸¸åšã€‚

å¦‚æœå¯¼è‡´æº¢å‡ºï¼šåˆ™æº¢å‡ºã€‚

å¦‚æœå·¦ç§»å¤ªå¤šï¼ˆæ¯”å¦‚int32å·¦ç§»32ä½ï¼‰ï¼šåˆ™æ— è§†æ­¤æ¬¡æ“ä½œã€‚

å¦‚æœè´Ÿæ•°å·¦ç§»ï¼šå¯¹å…¶æ‰€å¯¹åº”çš„è¡¥ç è¿›è¡Œå·¦ç§»æ“ä½œåå†è®¡ç®—è¡¥ç ã€‚

ä¸GCCä¸€è‡´ã€‚

### 6. The sign of the remainder on integer division (C90 6.3.5).

- æ•´æ•°é™¤æ³•ä½™æ•°çš„ç¬¦å·ã€‚

- åœ¨C11ä¸­å·²ä¸æ˜¯å®ç°å®šä¹‰è¡Œä¸ºã€‚

```c
#include <stdio.h>
#include <wchar.h>
#include <stdint.h>

int main(int argc, char *argv[]){
    int a1 = 5, b1 = 2;
    int a2 = -5, b2 = 2;
    int a3 = 5, b3 = -2;
    int a4 = -5, b4 = -2;

    // è¿›è¡Œé™¤æ³•è¿ç®—å¹¶è¾“å‡ºç»“æœ
    printf("a1 / b1 = %d, a1 %% b1 = %d\n", a1 / b1, a1 % b1);
    printf("a2 / b2 = %d, a2 %% b2 = %d\n", a2 / b2, a2 % b2);
    printf("a3 / b3 = %d, a3 %% b3 = %d\n", a3 / b3, a3 % b3);
    printf("a4 / b4 = %d, a4 %% b4 = %d\n", a4 / b4, a4 % b4);

    return 0;
}

```

```c
//target_gcc
a1 / b1 = 2, a1 % b1 = 1
a2 / b2 = -2, a2 % b2 = -1
a3 / b3 = -2, a3 % b3 = 1
a4 / b4 = 2, a4 % b4 = -1
```

```c
//target_clang
a1 / b1 = 2, a1 % b1 = 1
a2 / b2 = -2, a2 % b2 = -1
a3 / b3 = -2, a3 % b3 = 1
a4 / b4 = 2, a4 % b4 = -1
```

GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.

LLVMä¸GCCä¸€è‡´ï¼Œéƒ½æ˜¯å‘0æˆªæ–­ï¼Œé™¤æ³•çš„ç»“æœæ€»æ˜¯è¶‹å‘äºé›¶ï¼Œä½™æ•°çš„ç¬¦å·ä¸è¢«é™¤æ•°ç›¸åŒã€‚

## 6. Floating Point

### 1. The accuracy of the floating-point operations and of the library functions in [<math.h>](https://port70.net/~nsz/c/c11/n1570.html#7.12) and [<complex.h>](https://port70.net/~nsz/c/c11/n1570.html#7.3) that return floating-point results ([5.2.4.2.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.4.2.2)).

- æµ®ç‚¹è¿ç®—å’Œè¿”å›æµ®ç‚¹ç»“æœçš„ `<math.h>` å’Œ `<complex.h>` åº“å‡½æ•°çš„ç²¾åº¦ã€‚

```c
#include <stdio.h>
#include <math.h>

int main(int argc, char *argv[]){
    float f = 0.1f;
    double d = 0.1;
    long double ld = 0.1L;
    
    double x = 1.0;
    double sin_x = sin(x);
    double cos_x = cos(x);
    double sqrt_x = sqrt(x);

    printf("f = %f\n", f);
    printf("d = %f\n", d);
    printf("ld = %Lf\n", ld);
    printf("sin(%f) = %f\n", x, sin_x);
    printf("cos(%f) = %f\n", x, cos_x);
    printf("sqrt(%f) = %f\n", x, sqrt_x);
}
```

`Makefile`ä¸­ï¼Œ`FOLLOW_OPTION`æ”¹ä¸º`FOLLOW_OPTION = -lm`ã€‚

```c
//target_gcc
f = 0.100000
d = 0.100000
ld = 0.100000
sin(1.000000) = 0.841471
cos(1.000000) = 0.540302
sqrt(1.000000) = 1.000000
```

```c
//target_clang
f = 0.100000
d = 0.100000
ld = 0.100000
sin(1.000000) = 0.841471
cos(1.000000) = 0.540302
sqrt(1.000000) = 1.000000
```

å…¶ä½™å®éªŒçœç•¥ã€‚

ä¸GCCä¸€è‡´ã€‚

### 2. The rounding behaviors characterized by non-standard values of FLT_ROUNDS ([5.2.4.2.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.4.2.2)).

- ç”± FLT_ROUNDS éæ ‡å‡†å€¼å®šä¹‰çš„èˆå…¥è¡Œä¸ºã€‚

`FLT_ROUNDS` æ˜¯ä¸€ä¸ªç”±Cæ ‡å‡†åº“å®šä¹‰å’Œç®¡ç†çš„å®ï¼Œå®ƒçš„å®ç°å’Œä½¿ç”¨æ˜¯ä¸æ ‡å‡†åº“ç›¸å…³çš„ï¼Œè€Œä¸æ˜¯ä¸LLVMç¼–è¯‘å™¨ç›´æ¥ç›¸å…³ã€‚

GCC does not use such values.

æ¨æµ‹LLVMä¸GCCä¸€è‡´ã€‚

### 3. The evaluation methods characterized by non-standard negative values of FLT_EVAL_METHOD ([5.2.4.2.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.4.2.2)).

- ç”± FLT_EVAL_METHOD éæ ‡å‡†è´Ÿå€¼å®šä¹‰çš„æ±‚å€¼æ–¹æ³•ã€‚

> The `__FLT_EVAL_METHOD__` is not defined as a traditional macro, and so it will not appear when dumping preprocessor macros. Instead, the value `__FLT_EVAL_METHOD__` expands to is determined at the point of expansion either from the value set by the `-ffp-eval-method` command line option or from the target. This is because the `__FLT_EVAL_METHOD__` macro cannot expand to the correct evaluation method in the presence of a `#pragma` which alters the evaluation method. An error is issued if `__FLT_EVAL_METHOD__` is expanded inside a scope modified by `#pragma clang fp eval_method`.

æš‚æ—¶æ£€ç´¢ä¸åˆ°æ–‡æ¡£èƒ½è¯æ˜LLVM/Clang å¹¶ä¸ä½¿ç”¨ `FLT_EVAL_METHOD` çš„éæ ‡å‡†è´Ÿå€¼ã€‚

æ¨æµ‹LLVMä¸GCCä¸€è‡´ã€‚

### 4. The direction of rounding when an integer is converted to a floating-point number that cannot exactly represent the original value ([6.3.1.4](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.4)).

- å½“æ•´æ•°è¢«è½¬æ¢ä¸ºæµ®ç‚¹æ•°æ—¶ï¼Œå¦‚æœæµ®ç‚¹æ•°æ— æ³•ç²¾ç¡®è¡¨ç¤ºåŸå§‹å€¼æ—¶çš„èˆå…¥æ–¹å‘ã€‚

```c
#include <stdio.h>
#include <float.h>
#include <math.h>

int main(){
    int large_int = 16777217;  // 2^24 + 1ï¼Œè¶…å‡º float çš„ç²¾åº¦èŒƒå›´
    float f = (float)large_int;
    printf("Integer: %d, as float: %.0f\n", large_int, f);
    return 0;
}
```

```c
//target_gcc
Integer: 16777217, as float: 16777216
```

```c
//target_clang
Integer: 16777217, as float: 16777216
```

GCCæ”¯æŒC99 Annex Fï¼ˆè‡³å°‘æ„å›¾ä¸Šæ˜¯æƒ³æ”¯æŒçš„ï¼‰ï¼Œä½†æ˜¯ä¼¼ä¹LLVMå¹¶éå¦‚æ­¤ï¼Œå‚è§[clang sanitizer regards IEC 60559 floating-point division by zero as undefined Â· Issue #17374 Â· llvm/llvm-project (github.com)](https://github.com/llvm/llvm-project/issues/17374)

ä½†åœ¨è¿™ä¸ªé—®é¢˜ä¸Šè¿˜æ˜¯ä¸GCCä¸€è‡´ï¼Œä¹Ÿå°±æ˜¯`round to nearest, ties to even`ã€‚

### 5. The direction of rounding when a floating-point number is converted to a narrower floating-point number ([6.3.1.5](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.5)).

- å½“æµ®ç‚¹æ•°è½¬æ¢ä¸ºè¾ƒçª„çš„æµ®ç‚¹æ•°æ—¶çš„èˆå…¥æ–¹å‘ã€‚

```c
#include <stdio.h>
#include <float.h>
#include <math.h>

int main() {
    // å®šä¹‰ä¸€äº›åŒç²¾åº¦æµ®ç‚¹æ•°
    double num1 = 1.1234567890123456789;
    double num2 = 1.9876543210987654321;
    double num3 = 1.9999999999999999999;
    double num4 = 1.9999999999999999445; // éå¸¸æ¥è¿‘ä½†ç•¥å°äº2çš„æ•°
    double num5 = 2.0;

    // å°†åŒç²¾åº¦æµ®ç‚¹æ•°è½¬æ¢ä¸ºå•ç²¾åº¦æµ®ç‚¹æ•°ï¼Œå¹¶è¾“å‡ºç»“æœ
    float f1 = (float)num1;
    float f2 = (float)num2;
    float f3 = (float)num3;
    float f4 = (float)num4;
    float f5 = (float)num5;

    printf("num1: %.20f -> %.20f\n", num1, f1);
    printf("num2: %.20f -> %.20f\n", num2, f2);
    printf("num3: %.20f -> %.20f\n", num3, f3);
    printf("num4: %.20f -> %.20f\n", num4, f4);
    printf("num5: %.20f -> %.20f\n", num5, f5);

    return 0;
}
```

```c
//target_gcc
num1: 1.12345678901234569125 -> 1.12345683574676513672
num2: 1.98765432109876538647 -> 1.98765432834625244141
num3: 2.00000000000000000000 -> 2.00000000000000000000
num4: 2.00000000000000000000 -> 2.00000000000000000000
num5: 2.00000000000000000000 -> 2.00000000000000000000
```

```c
//target_clang
num1: 1.12345678901234569125 -> 1.12345683574676513672
num2: 1.98765432109876538647 -> 1.98765432834625244141
num3: 2.00000000000000000000 -> 2.00000000000000000000
num4: 2.00000000000000000000 -> 2.00000000000000000000
num5: 2.00000000000000000000 -> 2.00000000000000000000
```

åŒæ ·æ˜¯`round to nearest, ties to even`ã€‚

ä¸GCCä¸€è‡´ã€‚

### 6. How the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value is chosen for certain floating constants ([6.4.4.2](https://port70.net/~nsz/c/c11/n1570.html#6.4.4.2)).

- å¦‚ä½•ä¸ºæŸäº›æµ®ç‚¹å¸¸é‡é€‰æ‹©æœ€è¿‘å¯è¡¨ç¤ºå€¼ï¼Œæˆ–è€…é€‰æ‹©ç´§é‚»æœ€è¿‘å¯è¡¨ç¤ºå€¼çš„è¾ƒå¤§æˆ–è¾ƒå°çš„å¯è¡¨ç¤ºå€¼ã€‚

åŒæ ·æ˜¯`round to nearest, ties to even`ã€‚

ä¸GCCä¸€è‡´ã€‚

### 7. Whether and how floating expressions are contracted when not disallowed by the FP_CONTRACT pragma ([6.5](https://port70.net/~nsz/c/c11/n1570.html#6.5)).

- å½“ FP_CONTRACT ç¼–è¯‘æŒ‡ç¤ºæœªç¦æ­¢æ—¶ï¼Œæ˜¯å¦ä»¥åŠå¦‚ä½•æ”¶ç¼©æµ®ç‚¹è¡¨è¾¾å¼ã€‚

é»˜è®¤å…è®¸

[Clang Compiler Userâ€™s Manual â€” Clang 11 documentation (llvm.org)](https://releases.llvm.org/11.0.0/tools/clang/docs/UsersManual.html)

> `-ffp-contract=<value>`
>
> Specify when the compiler is permitted to form fused floating-point operations, such as fused multiply-add (FMA). Fused operations are permitted to produce more precise results than performing the same operations separately.
>
> The C standard permits intermediate floating-point results within an expression to be computed with more precision than their type would normally allow. This permits operation fusing, and Clang takes advantage of this by default. This behavior can be controlled with the `FP_CONTRACT` pragma. Please refer to the pragma documentation for a description of how the pragma interacts with this option.
>
> Valid values are:
>
> - `fast` (everywhere)
> - `on` (according to FP_CONTRACT pragma, default)
> - `off` (never fuse)

ä¸GCCä¸åŒï¼ŒGCCæ²¡æœ‰å®ç°`FP_CONTRACT` *pragma*ã€‚

### 8. The default state for the FENV_ACCESS pragma ([7.6.1](https://port70.net/~nsz/c/c11/n1570.html#7.6.1)).

- FENV_ACCESS ç¼–è¯‘æŒ‡ç¤ºçš„é»˜è®¤çŠ¶æ€ã€‚

å¯¹äºLLVMè€Œè¨€ï¼Œ`#pragma STDC FENV_ACCESS`æ˜¯æ”¯æŒçš„[âš™ D69272 Enable '#pragma STDC FENV_ACCESS' in frontend (llvm.org)](https://reviews.llvm.org/D69272?id=227690)ã€‚

é»˜è®¤ä¸ºoffï¼Œå¦‚æœå¯ç”¨äº†`-frounding-math`é€‰é¡¹ï¼ŒLLVMä¼šå‡è®¾ä»£ç å¯èƒ½ä¿®æ”¹æµ®ç‚¹ç¯å¢ƒä¸­çš„èˆå…¥æ¨¡å¼ï¼Œè¿™ç›¸å½“äºéšå¼åœ°å¼€å¯äº†`FENV_ACCESS`ã€‚[Clang Compiler Userâ€™s Manual â€” Clang 11 documentation (llvm.org)](https://releases.llvm.org/11.0.0/tools/clang/docs/UsersManual.html)

> The option -frounding-math forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable.

ä¸GCCä¸ä¸€è‡´ã€‚

### 9. Additional floating-point exceptions, rounding modes, environments, and classifications, and their macro names ([7.6](https://port70.net/~nsz/c/c11/n1570.html#7.6), [7.12](https://port70.net/~nsz/c/c11/n1570.html#7.12)).

- é¢å¤–çš„æµ®ç‚¹å¼‚å¸¸ã€èˆå…¥æ¨¡å¼ã€ç¯å¢ƒå’Œåˆ†ç±»åŠå…¶å®åç§°ã€‚
- This is dependent on the implementation of the C library.

### 10.The default state for the FP_CONTRACT pragma ([7.12.2](https://port70.net/~nsz/c/c11/n1570.html#7.12.2)).

- FP_CONTRACT ç¼–è¯‘æŒ‡ç¤ºçš„é»˜è®¤çŠ¶æ€ã€‚

FP_CONTRACTç¼–è¯‘æŒ‡ç¤ºç¬¦çš„é»˜è®¤çŠ¶æ€æ˜¯`on`

> Specify when the compiler is permitted to form fused floating-point operations, such as fused multiply-add (FMA). Fused operations are permitted to produce more precise results than performing the same operations separately.
>
> The C standard permits intermediate floating-point results within an expression to be computed with more precision than their type would normally allow. This permits operation fusing, and Clang takes advantage of this by default. This behavior can be controlled with the `FP_CONTRACT` pragma. Please refer to the pragma documentation for a description of how the pragma interacts with this option.
>
> Valid values are:
>
> - `fast` (everywhere)
> - `on` (according to FP_CONTRACT pragma, default)
> - `off` (never fuse)

ä¸GCCä¸åŒï¼ŒGCCæ²¡æœ‰å®ç°`FP_CONTRACT` pragmaã€‚

### 11. Whether the â€œinexactâ€ floating-point exception can be raised when the rounded result actually does equal the mathematical result in an IEC 60559 conformant implementation (C99 F.9).

- å½“èˆå…¥ç»“æœå®é™…ä¸Šç­‰äºç¬¦åˆ IEC 60559 çš„å®ç°ä¸­çš„æ•°å­¦ç»“æœæ—¶ï¼Œæ˜¯å¦ä¼šå¼•å‘â€œä¸ç²¾ç¡®â€æµ®ç‚¹å¼‚å¸¸ã€‚
- åœ¨C11ä¸­å·²ä¸æ˜¯å®ç°å®šä¹‰è¡Œä¸ºã€‚
- This is dependent on the implementation of the C library.

### 12. Whether the â€œunderflowâ€ (and â€œinexactâ€) floating-point exception can be raised when a result is tiny but not inexact in an IEC 60559 conformant implementation (C99 F.9).

- å½“ç»“æœå¾ˆå°ä½†ä¸ç²¾ç¡®æ—¶ï¼Œåœ¨ç¬¦åˆ IEC 60559 çš„å®ç°ä¸­æ˜¯å¦å¯ä»¥å¼•å‘â€œä¸‹æº¢â€ï¼ˆå’Œâ€œä¸ç²¾ç¡®â€ï¼‰æµ®ç‚¹å¼‚å¸¸ã€‚
- åœ¨C11ä¸­å·²ä¸æ˜¯å®ç°å®šä¹‰è¡Œä¸ºã€‚
- This is dependent on the implementation of the C library.

## 7. Arrays and Pointers

### 1. The result of converting a pointer to an integer or vice versa ([6.3.2.3](https://port70.net/~nsz/c/c11/n1570.html#6.3.2.3)).

- å°†æŒ‡é’ˆè½¬æ¢ä¸ºæ•´æ•°æˆ–å°†æ•´æ•°è½¬æ¢ä¸ºæŒ‡é’ˆçš„ç»“æœã€‚

> The â€˜`inttoptr`â€™ instruction converts `value` to type `ty2` by applying either a zero extension or a truncation depending on the size of the integer `value`. If `value` is larger than the size of a pointer then a truncation is done. If `value` is smaller than the size of a pointer then a zero extension is done. If they are the same size, nothing is done (*no-op cast*).

> The â€˜`ptrtoint`â€™ instruction converts `value` to integer type `ty2` by interpreting the pointer value as an integer and either truncating or zero extending that value to the size of the integer type. If `value` is smaller than `ty2` then a zero extension is done. If `value` is larger than `ty2` then a truncation is done. If they are the same size, then nothing is done (*no-op cast*) other than a type change.

ä¸GCCåŸºæœ¬ä¸€è‡´ã€‚

### 2. The size of the result of subtracting two pointers to elements of the same array ([6.5.6](https://port70.net/~nsz/c/c11/n1570.html#6.5.6)).

- å¯¹åŒä¸€æ•°ç»„ä¸­å…ƒç´ çš„ä¸¤ä¸ªæŒ‡é’ˆè¿›è¡Œå‡æ³•è¿ç®—çš„ç»“æœå¤§å°ã€‚
- The value is as specified in the standard and the type is determined by the ABI.

```c
#include <stdio.h>
#include <stddef.h>

int main() {
    int arr[10];  // å®šä¹‰ä¸€ä¸ªåŒ…å« 10 ä¸ªå…ƒç´ çš„æ•°ç»„
    int *ptr1 = &arr[2];  // æŒ‡å‘æ•°ç»„ä¸­ç¬¬ 3 ä¸ªå…ƒç´ ï¼ˆç´¢å¼•ä¸º 2ï¼‰
    int *ptr2 = &arr[7];  // æŒ‡å‘æ•°ç»„ä¸­ç¬¬ 8 ä¸ªå…ƒç´ ï¼ˆç´¢å¼•ä¸º 7ï¼‰
    
    // è®¡ç®—ä¸¤ä¸ªæŒ‡é’ˆä¹‹é—´çš„å·®å€¼
    ptrdiff_t diff = ptr2 - ptr1;
    
    // æ‰“å°æŒ‡é’ˆå·®å€¼å’Œ ptrdiff_t ç±»å‹çš„å¤§å°
    printf("Difference between ptr2 and ptr1: %td\n", diff);
    printf("Size of ptrdiff_t: %zu bytes\n", sizeof(ptrdiff_t));
    
    return 0;
}
```

```c
//target_gcc
Difference between ptr2 and ptr1: 5
Size of ptrdiff_t: 8 bytes
```

```c
//target_clang
Difference between ptr2 and ptr1: 5
Size of ptrdiff_t: 8 bytes
```

åœ¨æœ¬å®éªŒç¯å¢ƒä¸‹ï¼Œç»“æœè¡¨ç¤ºè¿™ä¸¤ä¸ªæŒ‡é’ˆä¹‹é—´ç›¸éš”çš„å…ƒç´ æ•°é‡ã€‚

## 8. Hints

### 1. The extent to which suggestions made by using the register storage-class specifier are effective ([6.7.1](https://port70.net/~nsz/c/c11/n1570.html#6.7.1)).

- ä½¿ç”¨ `register` å­˜å‚¨ç±»è¯´æ˜ç¬¦çš„å»ºè®®æœ‰æ•ˆæ€§çš„ç¨‹åº¦ã€‚

[-Wdeprecated-register](https://releases.llvm.org/4.0.0/tools/clang/docs/DiagnosticsReference.html#id143)

åœ¨ç°ä»£ç¼–è¯‘å™¨ä¸­ï¼Œ`register` çš„ä½œç”¨å·²ç»éå¸¸æœ‰é™ï¼Œé™¤äº†åœ¨ä¸€äº›æç«¯æƒ…å†µæˆ–ç‰¹å®šå¹³å°ä¸‹æœ‰ç‰¹æ®Šä½œç”¨å¤–ï¼Œç¼–è¯‘å™¨çš„è‡ªåŠ¨ä¼˜åŒ–é€šå¸¸æ›´ä¸ºæœ‰æ•ˆã€‚

[Hints implementation (Using the GNU Compiler Collection (GCC))](https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Hints-implementation.html)

æ€»ä½“è€Œè¨€ï¼ŒLLVM å’Œ GCC ç±»ä¼¼ï¼Œå‡ ä¹ä¸å†ä¾èµ– `register` è¯´æ˜ç¬¦æ¥è¿›è¡Œä¼˜åŒ–ã€‚

### 2. The extent to which suggestions made by using the inline function specifier are effective ([6.7.4](https://port70.net/~nsz/c/c11/n1570.html#6.7.4)).

- ä½¿ç”¨ `inline` å‡½æ•°è¯´æ˜ç¬¦çš„å»ºè®®æœ‰æ•ˆæ€§çš„ç¨‹åº¦ã€‚

LLVMåœ¨`-O0`æƒ…å†µä¸‹ä¸ä¼šå†…è”å‡½æ•°ï¼ˆ[âš™ D28053 Cleanup the handling of noinline function attributes, -fno-inline, -fno-inline-functions, -O0, and optnone. (llvm.org)](https://reviews.llvm.org/D28053)ï¼‰ã€‚

æœ‰`noinline`å±æ€§æ—¶ä¸ä¼šå†…è”ï¼ˆæœ¬è´¨ä¸Š `clang -O0` now applies the noinline attribute everywhere. )ã€‚

å…¶ä»–æƒ…å†µä¹Ÿä¼šå¯¼è‡´ä¸ä¼šå†…è”ã€‚

ä¸‹é¢æ˜¯å‚è€ƒçš„ç½‘é¡µï¼š

[Clang command line argument reference â€” Clang 20.0.0git documentation (llvm.org)](https://clang.llvm.org/docs/ClangCommandLineReference.html)

[C++'s "inline" - how strong a hint is it for GCC and Clang/LLVM? - Stack Overflow](https://stackoverflow.com/questions/5223690/cs-inline-how-strong-a-hint-is-it-for-gcc-and-clang-llvm)

[3.2. Inlining â€” Clang 20.0.0git documentation (llvm.org)](https://clang.llvm.org/docs/analyzer/developer-docs/IPA.html)

å¤§ä½“ä¸Šä¸GCCä¸€è‡´ã€‚

## 9. Structures, Unions, Enumerations, and Bit-Fields

### 1. A member of a union object is accessed using a member of a different type (C90 6.3.2.3).

- ä½¿ç”¨ä¸åŒç±»å‹çš„æˆå‘˜è®¿é—®è”åˆå¯¹è±¡çš„æˆå‘˜ã€‚
- åœ¨C11å·²ä¸æ˜¯å®ç°å®šä¹‰è¡Œä¸ºã€‚

The relevant bytes of the representation of the object are treated as an object of the type used for the access. See Type-punning. 

[Unions â€” Mapping High Level Constructs to LLVM IR documentation (mapping-high-level-constructs-to-llvm-ir.readthedocs.io)](https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/basic-constructs/unions.html)

[clang-tidy - cppcoreguidelines-pro-type-union-access â€” Extra Clang Tools 20.0.0git documentation (llvm.org)](https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/pro-type-union-access.html)

ä¸GCCä¸€è‡´ã€‚

### 2. Whether a ''plain'' int bit-field is treated as a signed int bit-field or as an unsigned int bit-field ([6.7.2](https://port70.net/~nsz/c/c11/n1570.html#6.7.2), [6.7.2.1](https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1)). 

- "æ™®é€š" int ä½å­—æ®µæ˜¯è¢«å½“ä½œæœ‰ç¬¦å· int ä½å­—æ®µè¿˜æ˜¯æ— ç¬¦å· int ä½å­—æ®µã€‚

```c
#include <stdio.h>

struct Test {
    signed int signed_bitfield : 4;  // æ˜ç¡®å£°æ˜ä¸ºæœ‰ç¬¦å·çš„ä½åŸŸ
    unsigned int unsigned_bitfield : 4;  // æ˜ç¡®å£°æ˜ä¸ºæ— ç¬¦å·çš„ä½åŸŸ
    int plain_bitfield : 4;  // ä¸æ˜ç¡®è¯´æ˜æ˜¯æœ‰ç¬¦å·è¿˜æ˜¯æ— ç¬¦å·ï¼Œå±äºâ€œplain intâ€
};

int main() {
    struct Test t;

    // èµ‹å€¼ä¸ºè´Ÿæ•°ï¼Œè§‚å¯Ÿæ˜¯å¦æº¢å‡ºï¼ˆæœ‰ç¬¦å·ï¼‰æˆ–è€…æˆªæ–­ï¼ˆæ— ç¬¦å·ï¼‰
    t.signed_bitfield = -5;
    t.unsigned_bitfield = -5;
    t.plain_bitfield = -5;

    // æ‰“å°ç»“æœ
    printf("signed_bitfield (int): %d\n", t.signed_bitfield);      // é¢„æœŸè¾“å‡ºï¼š-5
    printf("unsigned_bitfield (unsigned int): %u\n", t.unsigned_bitfield); // é¢„æœŸè¾“å‡ºï¼š5
    printf("plain_bitfield (plain int): %d\n", t.plain_bitfield);   // è§‚å¯Ÿ GCC å’Œ LLVM çš„è¡Œä¸º

    return 0;
}
```

```c
//target_gcc
signed_bitfield (int): -5
unsigned_bitfield (unsigned int): 11
plain_bitfield (plain int): -5
```

```c
//target_clang
signed_bitfield (int): -5
unsigned_bitfield (unsigned int): 11
plain_bitfield (plain int): -5
```

è¢«è§†ä¸ºsigned int

[âš™ D131255 Fix Wbitfield-constant-conversion on 1-bit signed bitfield (llvm.org)](https://reviews.llvm.org/D131255)

ä¸GCCä¸€è‡´ã€‚

### 3. Allowable bit-field types other than _Bool, signed int, and unsigned int ([6.7.2.1](https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1)).

- é™¤äº† `_Bool`ã€`signed int` å’Œ `unsigned int` ä¹‹å¤–çš„å¯å…è®¸ä½å­—æ®µç±»å‹ã€‚

Other integer types, such as `long int`, and enumerated types are permitted even in strictly conforming mode.

è§[llvm/llvm-project: The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. (github.com)](https://github.com/llvm/llvm-project)ä¸­`llvm/include/llvm/ADT/Bitfields.h`

ä¸GGCä¸€è‡´ã€‚

### 4. Whether atomic types are permitted for bit-fields ([6.7.2.1](https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1)).

- æ˜¯å¦å…è®¸ä½å­—æ®µä½¿ç”¨åŸå­ç±»å‹ã€‚

```c
#include <stdio.h>
#include <stddef.h>

_Atomic int flag : 1;               

int main() {
    
    return 0;
}
```

```bash
$ make gcc
gcc --std=c11  ./test.c -o target_gcc
./test.c:4:18: error: expected â€˜=â€™, â€˜,â€™, â€˜;â€™, â€˜asmâ€™ or â€˜__attribute__â€™ before â€˜:â€™ token
    4 | _Atomic int flag : 1;
      |                  ^
make: *** [Makefile:16: gcc] Error 1
```

```bash
$ make clang
clang --std=c11  ./test.c -o target_clang
./test.c:4:18: error: expected ';' after top level declarator
_Atomic int flag : 1;
                 ^
                 ;
./test.c:4:20: error: expected identifier or '('
_Atomic int flag : 1;
                   ^
2 errors generated.
make: *** [Makefile:21: clang] Error 1
```

LLVM çš„ç±»å‹ç³»ç»Ÿéå¸¸ä¸¥æ ¼ï¼ŒåŸå­æ“ä½œåœ¨ LLVM IR ä¸­æ˜¯é€šè¿‡ç‰¹å®šçš„æŒ‡ä»¤ï¼ˆå¦‚ `atomicrmw` å’Œ `cmpxchg`ï¼‰å®ç°çš„ï¼Œè¿™äº›æŒ‡ä»¤è¦æ±‚æ“ä½œçš„å¯¹è±¡æ˜¯ä¸€ä¸ªå®Œæ•´çš„å˜é‡ï¼Œè€Œä¸æ˜¯éƒ¨åˆ†ä½ï¼ˆå³ä½åŸŸï¼‰ã€‚å› æ­¤ï¼Œåœ¨ LLVM ä¸­å®ç°å¯¹ä½åŸŸçš„åŸå­æ“ä½œæ˜¯éå¸¸å¤æ‚å’Œä¸åˆ‡å®é™…çš„ï¼Œè¿™ç§è®¾è®¡å¯èƒ½å¯¼è‡´ LLVM ä¸æ”¯æŒå°†åŸå­ç±»å‹ç”¨ä½œä½åŸŸã€‚

éƒ½ä¸å¯ä»¥ï¼Œä¸GCCä¸€è‡´ã€‚

### 5. Whether a bit-field can straddle a storage-unit boundary ([6.7.2.1](https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1)).

- ä½å­—æ®µæ˜¯å¦å¯ä»¥è·¨è¶Šå­˜å‚¨å•å…ƒè¾¹ç•Œã€‚
- Determined by ABI.

åœ¨æœ¬å®éªŒç¯å¢ƒä¸­ï¼š
```c
#include <stdio.h>

struct TestBitField {
    unsigned int field1 : 7;   // 7 bits
    unsigned int field5 : 1;   // 1 bit (total 8 bits, may fit in one byte)
};

int main() {
    struct TestBitField test;

    printf("Size of struct: %lu bytes\n", sizeof(test));
    
    test.field1 = 0xFF;  // Set maximum value for 7 bits
    //test.field5 = 0x1;   // Set maximum value for 1 bit

    printf("field1: 0x%X\n", test.field1);
    printf("field5: 0x%X\n", test.field5);

    return 0;
}
```

```c
//target_gcc
Size of struct: 4 bytes
field1: 0x7F
field5: 0x0
```

```c
//target_clang
Size of struct: 4 bytes
field1: 0x7F
field5: 0x0
```

æ ¹æ®è¯¥å®éªŒï¼Œåœ¨æœ¬å®éªŒç¯å¢ƒä¸­ä¸å¯ä»¥è·¨è¶Šã€‚

### 6. The order of allocation of bit-fields within a unit ([6.7.2.1](https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1)).

- ä½å­—æ®µåœ¨å•å…ƒå†…çš„åˆ†é…é¡ºåºã€‚
- Determined by ABI.

```c
#include <stdio.h>

struct TestBitField {
    unsigned int field1 : 3;   // 3 bits
    unsigned int field2 : 4;   // 4 bits
    unsigned int field3 : 5;   // 5 bits
    unsigned int field4 : 6;   // 6 bits
    unsigned int field5 : 7;   // 7 bits (total 25 bits, fits in one 32-bit unit)
};

void print_bits(unsigned int num) {
    for (int i = 31; i >= 0; i--) {
        printf("%d", (num >> i) & 1);
        if (i % 8 == 0) {
            printf(" ");  // Add space for readability
        }
    }
    printf("\n");
}

int main() {
    struct TestBitField test = {0};

    test.field1 = 5;   // 3-bit field, 101 in binary
    test.field2 = 10;  // 4-bit field, 1010 in binary
    test.field3 = 17;  // 5-bit field, 10001 in binary
    test.field4 = 33;  // 6-bit field, 100001 in binary
    test.field5 = 127; // 7-bit field, 1111111 in binary

    printf("Size of struct: %lu bytes\n", sizeof(test));
    
    // Print the entire bit pattern of the structure
    printf("Bit pattern of struct:\n");
    print_bits(*(unsigned int*)&test);

    printf("field1: %u\n", test.field1);
    printf("field2: %u\n", test.field2);
    printf("field3: %u\n", test.field3);
    printf("field4: %u\n", test.field4);
    printf("field5: %u\n", test.field5);

    return 0;
}
```

```c
//target_gcc
Size of struct: 4 bytes
Bit pattern of struct:
00000001 11111110 00011000 11010101 
field1: 5
field2: 10
field3: 17
field4: 33
field5: 127
```

```c
//target_clang
Size of struct: 4 bytes
Bit pattern of struct:
00000001 11111110 00011000 11010101 
field1: 5
field2: 10
field3: 17
field4: 33
field5: 127
```

åœ¨æœ¬å®éªŒç¯å¢ƒä¸‹ï¼ŒGCCå’ŒClangåœ¨å¤„ç†ä½åŸŸçš„åˆ†é…æ—¶ï¼Œé‡‡ç”¨äº†ç›¸åŒçš„è§„åˆ™ã€‚ä½åŸŸä»ä½ä½åˆ°é«˜ä½åˆ†é…ï¼ŒæŒ‰ç…§å£°æ˜é¡ºåºä»ä½ä½å¼€å§‹å¡«å……ã€‚

### 7. The alignment of non-bit-field members of structures ([6.7.2.1](https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1)). 

- ç»“æ„ä½“ä¸­éä½å­—æ®µæˆå‘˜çš„å¯¹é½ã€‚
- Determined by ABI.

```c
#include <stdio.h>
#include <stddef.h>

struct Test {
    char c1;      // å­—ç¬¦ç±»å‹ï¼Œå 1ä¸ªå­—èŠ‚
    int i;        // æ•´å‹ï¼Œå 4ä¸ªå­—èŠ‚
    char c2;      // å­—ç¬¦ç±»å‹ï¼Œå 1ä¸ªå­—èŠ‚
};

int main() {
    struct Test t;
    
    // æ‰“å°ç»“æ„ä½“ Test çš„å¤§å°
    printf("Size of struct Test: %zu\n", sizeof(struct Test));

    // æ‰“å°å„ä¸ªæˆå‘˜åœ¨ç»“æ„ä½“ä¸­çš„åç§»é‡
    printf("Offset of c1: %zu\n", offsetof(struct Test, c1));
    printf("Offset of i: %zu\n", offsetof(struct Test, i));
    printf("Offset of c2: %zu\n", offsetof(struct Test, c2));

    return 0;
}
```

```c
//target_gcc
Size of struct Test: 12
Offset of c1: 0
Offset of i: 4
Offset of c2: 8
```

```c
//target_clang
Size of struct Test: 12
Offset of c1: 0
Offset of i: 4
Offset of c2: 8
```

åœ¨æœ¬å®éªŒç¯å¢ƒä¸‹ï¼ŒGCCä¸LLVMå¯¹é½æ–¹å¼ä¸€è‡´ã€‚

### 8. The integer type compatible with each enumerated type ([6.7.2.2](https://port70.net/~nsz/c/c11/n1570.html#6.7.2.2)).

- ä¸æ¯ä¸ªæšä¸¾ç±»å‹å…¼å®¹çš„æ•´æ•°ç±»å‹

> An enum type is represented by an underlying integer type. The size of the integer type and whether it is signed is based on the range of values of the enumerated constants.
>
> By default, the c29clang uses the smallest possible byte size for the enumeration type. The underlying type is the first type in the following list in which all the enumerated constant values can be represented: *signed char*, *unsigned char*, *short*, *unsigned short*, *int*, *unsigned int*, *long*, *unsigned long*, *long long*, *unsigned long long*. This default behavior is equivalent to the effect of using the **c29clang** *-fshort-enums* option.
>
> In strict c89/c99/c11 mode, the compiler will limit enumeration constants to those values that fit in *int* or *unsigned int*.
>
> For C++ and gnuXX C dialects (relaxed c89/c99/c11), the compiler allows enumeration constants up to the largest integral type (64 bits).
>
> You can alter the default compiler behavior using the *-fno-short-enums* option. When the *-fno-short-enums* option is used in strict c89/c99/c11 mode, the enumeration type used to represent an *enum* will be *int*, even if the values of the enumeration constants fit into a smaller integer type.
>
> When the *fno-short-enums* option is used with C++ or gnuXX C dialects, the underlying enumeration type will be the first type in the following list in which all the enumerated constant values can be represented: *int*, *unsigned int*, *long*, *unsigned long*, *long long*, *unsigned long long*.

[2.1. Data Types â€” C29 Clang Compiler Tools User's Guide (ti.com)](https://software-dl.ti.com/codegen/docs/c29clang/rel0_1_0_STS/compiler_manual/c_cpp_language_implementation/data_types.html)

å¤§è‡´ä¸GCCä¸€è‡´ï¼Œæ³¨æ„åˆ°clangåŒæ ·æœ‰optionï¼š

> - **-fshort-enums**, **-fno-short-enums**
>
> 
>
> Allocate to an enum type only as many bytes as it needs for the declared range of possible values

## 10. Qualifiers

### 1. What constitutes an access to an object that has volatile-qualified type ([6.7.3](https://port70.net/~nsz/c/c11/n1570.html#6.7.3)).

- è®¿é—®å…·æœ‰ `volatile` é™å®šç±»å‹çš„å¯¹è±¡çš„è¡Œä¸ºã€‚

> Certain memory accesses, such as [load](https://llvm.org/docs/LangRef.html#i-load)â€™s, [store](https://llvm.org/docs/LangRef.html#i-store)â€™s, and [llvm.memcpy](https://llvm.org/docs/LangRef.html#int-memcpy)â€™s may be marked `volatile`. The optimizers must not change the number of volatile operations or change their order of execution relative to other volatile operations. The optimizers *may* change the order of volatile operations relative to non-volatile operations. This is not Javaâ€™s â€œvolatileâ€ and has no cross-thread synchronization behavior.
>
> A volatile load or store may have additional target-specific semantics. Any volatile operation can have side effects, and any volatile operation can read and/or modify state which is not accessible via a regular load or store in this module. Volatile operations may use addresses which do not point to memory (like MMIO registers). This means the compiler may not use a volatile operation to prove a non-volatile access to that address has defined behavior.
>
> The allowed side-effects for volatile accesses are limited. If a non-volatile store to a given address would be legal, a volatile operation may modify the memory at that address. A volatile operation may not modify any other memory accessible by the module being compiled. A volatile operation may not call any code in the current module.
>
> In general (without target specific context), the address space of a volatile operation may not be changed. Different address spaces may have different trapping behavior when dereferencing an invalid pointer.
>
> The compiler may assume execution will continue after a volatile operation, so operations which modify memory or may have undefined behavior can be hoisted past a volatile operation.
>
> As an exception to the preceding rule, the compiler may not assume execution will continue after a volatile store operation. This restriction is necessary to support the somewhat common pattern in C of intentionally storing to an invalid pointer to crash the program. In the future, it might make sense to allow frontends to control this behavior.
>
> IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy or llvm.memmove intrinsics even when those intrinsics are flagged volatile. Likewise, the backend should never split or merge target-legal volatile load/store instructions. Similarly, IR-level volatile loads and stores cannot change from integer to floating-point or vice versa.
>
> Rationale
>
> Platforms may rely on volatile loads and stores of natively supported data width to be executed as single instruction. For example, in C this holds for an l-value of volatile primitive type with native hardware support, but not necessarily for aggregate types. The frontend upholds these expectations, which are intentionally unspecified in the IR. The rules above ensure that IR transformations do not violate the frontendâ€™s contract with the language.
>
> [LLVM Language Reference Manual â€” LLVM 20.0.0git documentation](https://llvm.org/docs/LangRef.html#volatile-memory-accesses)

ä¸GCCå¤§è‡´ä¸€è‡´ã€‚

## 11. Declarators

### 1. The maximum number of declarators that may modify an arithmetic, structure or union type (C90 6.5.4).

- å¯ä¿®æ”¹ç®—æœ¯ç±»å‹ã€ç»“æ„æˆ–è”åˆç±»å‹çš„å£°æ˜ç¬¦çš„æœ€å¤§æ•°é‡ã€‚
- åœ¨C11å·²ä¸æ˜¯å®ç°å®šä¹‰è¡Œä¸ºã€‚

ä¸GCCä¸€è‡´ï¼Œä»…å—é™äºç¡¬ä»¶èµ„æºã€‚

## 12. Statements

### 1. The maximum number of `case` values in a `switch` statement (C90 6.6.4.2).

- `switch` è¯­å¥ä¸­ `case` å€¼çš„æœ€å¤§æ•°é‡ã€‚
- åœ¨C11å·²ä¸æ˜¯å®ç°å®šä¹‰è¡Œä¸ºã€‚

[class SwitchInst: LLVM/Clang 15.x documentation (hdoc.io)](https://docs.hdoc.io/hdoc/llvm-project/r1A6F1C03A3F0DA37.html)

LLVMçš„`SwitchInst`ç±»å…è®¸åŠ¨æ€æ·»åŠ `case`å€¼ï¼Œå¹¶ä¸”è¿™ä¸ªæ•°é‡ä»…å—ç³»ç»Ÿå†…å­˜çš„é™åˆ¶ï¼Œè€Œä¸æ˜¯ç¼–è¯‘å™¨æœ¬èº«çš„é™åˆ¶ã€‚

ä¸GCCä¸€è‡´ã€‚

## 13. Preprocessing Directives

è¯¥åˆ†ç±»ä¸‹çš„å®ç°å®šä¹‰è¡Œä¸ºæ— æ³•é€šè¿‡å®éªŒå¼€å±•å¯¹æ¯”ã€‚

åŒæ—¶ï¼ŒGCCçš„æ–‡æ¡£å¯¹æ­¤å¤„çš„å®ç°å®šä¹‰è¡Œä¸ºæå…¶è¯­ç„‰ä¸è¯¦ï¼ˆ[Implementation-defined behavior (The C Preprocessor) (gnu.org)](https://gcc.gnu.org/onlinedocs/cpp/Implementation-defined-behavior.html#Implementation-defined-behavior)ï¼‰

LLVMæ–‡æ¡£ä¸­ä¹Ÿæ²¡æœ‰å¯¹è¿™äº›è¡Œä¸ºçš„æ˜ç¡®è¯´æ˜ï¼Œæ•…ä»…èƒ½é€šè¿‡
[llvm-project/clang/lib/Lex/Preprocessor.cpp at main Â· llvm/llvm-project (github.com)](https://github.com/llvm/llvm-project/blob/main/clang/lib/Lex/Preprocessor.cpp)
[clang: clang::Preprocessor Class Reference (llvm.org)](https://clang.llvm.org/doxygen/classclang_1_1Preprocessor.html)
è¿›è¡Œé˜…è¯»å’Œå¯¹æ¯”ã€‚

LLVMä¸GCCå¤§è‡´ä¸€è‡´

## 14. Library Functions

The behavior of most of these points are dependent on the implementation of the C library.

æ•…å¤§éƒ¨åˆ†å‡è·³è¿‡ï¼ˆä¸GCCæ–‡æ¡£ä¿æŒä¸€è‡´ï¼‰ã€‚

### 1. The null pointer constant to which the macro NULL expands ([7.19](https://port70.net/~nsz/c/c11/n1570.html#7.19)).

- `NULL` å®æ‰©å±•åˆ°çš„ç©ºæŒ‡é’ˆå¸¸é‡æ˜¯ä»€ä¹ˆã€‚

GCC:In `<stddef.h>`, `NULL` expands to `((void *)0)`. GCC does not provide the other headers which define `NULL` and some library implementations may use other definitions in those headers.

LLVM:In `<stddef.h>`, `NULL` expands to `((void *)0)`.å¹¶ä¸”åœ¨LLVM/clangçš„å®ç°é‡Œä¹Ÿæ²¡æœ‰å…¶ä»–çš„å®å®šä¹‰ã€‚

ä¸GCCä¸€è‡´ã€‚

## 15. Architecture

### 1. The values or expressions assigned to the macros specified in the headers [<float.h>](https://port70.net/~nsz/c/c11/n1570.html#7.7), [<limits.h>](https://port70.net/~nsz/c/c11/n1570.html#7.10), and [<stdint.h>](https://port70.net/~nsz/c/c11/n1570.html#7.20) ([5.2.4.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.4.2), [7.20.2](https://port70.net/~nsz/c/c11/n1570.html#7.20.2), [7.20.3](https://port70.net/~nsz/c/c11/n1570.html#7.20.3)).

- åˆ†é…ç»™ `<float.h>`ã€`<limits.h>` å’Œ `<stdint.h>` å¤´æ–‡ä»¶ä¸­æŒ‡å®šå®çš„å€¼æˆ–è¡¨è¾¾å¼ã€‚

- Determined by ABI.

### 2. The result of attempting to indirectly access an object with automatic or thread storage duration from a thread other than the one with which it is associated ([6.2.4](https://port70.net/~nsz/c/c11/n1570.html#6.2.4)).

- ä»ä¸å¯¹è±¡å…³è”çš„çº¿ç¨‹ä»¥å¤–çš„çº¿ç¨‹é—´æ¥è®¿é—®å…·æœ‰è‡ªåŠ¨æˆ–çº¿ç¨‹å­˜å‚¨æœŸé™çš„å¯¹è±¡çš„ç»“æœã€‚

[LLVM Atomic Instructions and Concurrency Guide â€” LLVM 20.0.0git documentation](https://llvm.org/docs/Atomics.html)

> If you are writing a frontend which uses this directly, use with caution. Acquire only provides a semantic guarantee when paired with a Release operation.

æ€»ä½“è€Œè¨€è¿˜æ˜¯æ”¯æŒçš„ï¼Œä½†æ˜¯è¦éµå¾ªåŒæ­¥è¦æ±‚ã€‚

ä¸GCCä¸€è‡´ã€‚

### 3. The number, order, and encoding of bytes in any object (when not explicitly specified in this International Standard) ([6.2.6.1](https://port70.net/~nsz/c/c11/n1570.html#6.2.6.1)).

- ä»»ä½•å¯¹è±¡çš„å­—èŠ‚æ•°ã€é¡ºåºå’Œç¼–ç ï¼ˆå½“å›½é™…æ ‡å‡†æœªæ˜ç¡®è§„å®šæ—¶ï¼‰ã€‚
- Determined by ABI.

### 4. Whether any extended alignments are supported and the contexts in which they are supported ([6.2.8](https://port70.net/~nsz/c/c11/n1570.html#6.2.8)).

- æ˜¯å¦æ”¯æŒä»»ä½•æ‰©å±•å¯¹é½åŠå…¶æ”¯æŒçš„ä¸Šä¸‹æ–‡ã€‚
- Determined by ABI.

### 5. Valid alignment values other than those returned by an _Alignof expression for fundamental types, if any ([6.2.8](https://port70.net/~nsz/c/c11/n1570.html#6.2.8)).

- é™¤åŸºæœ¬ç±»å‹çš„ `_Alignof` è¡¨è¾¾å¼è¿”å›çš„å¯¹é½å€¼ä¹‹å¤–çš„æœ‰æ•ˆå¯¹é½å€¼ï¼ˆå¦‚æœæœ‰ï¼‰

> The â€˜`alloca`â€™ instruction allocates `sizeof(<type>)*NumElements` bytes of memory on the runtime stack, returning a pointer of the appropriate type to the program. If â€œNumElementsâ€ is specified, it is the number of elements allocated, otherwise â€œNumElementsâ€ is defaulted to be one.
>
> If a constant alignment is specified, the value result of the allocation is guaranteed to be aligned to at least that boundary. The alignment may not be greater than `1 << 32`.
>
> The alignment is only optional when parsing textual IR; for in-memory IR, it is always present. If not specified, the target can choose to align the allocation on any convenient boundary compatible with the type.
>
> â€˜`type`â€™ may be any sized type.
>
> Structs containing scalable vectors cannot be used in allocas unless all fields are the same scalable vector type (e.g. `{<vscale x 2 x i32>, <vscale x 2 x i32>}` contains the same type while `{<vscale x 2 x i32>, <vscale x 2 x i64>}` doesnâ€™t).

[LLVM Language Reference Manual â€” LLVM 20.0.0git documentation](https://llvm.org/docs/LangRef.html)

ä¸GCCä¸€è‡´ï¼Œä¹Ÿæ˜¯è¦2çš„å¹‚æ¬¡ï¼Œå¹¶ä¸”å°äº`1 << 32`

### 6. The value of the result of the sizeof and _Alignof operators ([6.5.3.4](https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4)).

- `sizeof` å’Œ `_Alignof` è¿ç®—ç¬¦çš„ç»“æœå€¼ã€‚
- Determined by ABI.

## 16. Locale-Specific Behavior

The behavior of these points are dependent on the implementation of the C library, and are not defined by GCC itself.

æ•…åœ¨æ­¤æ–‡æ¡£ä¸­è·³è¿‡ã€‚



## 17. æ€»ç»“

å¯¹äºå¤§éƒ¨åˆ†å®ç°å®šä¹‰è¡Œä¸ºè€Œè¨€ï¼ŒGCCå’ŒLLVMè¡Œä¸ºå‡ä¸€è‡´ã€‚

ä»¥ä¸‹å®ç°å®šä¹‰è¡Œä¸ºäºŒè€…ä¸ä¸€è‡´ï¼š

1. The mapping between physical source file multibyte characters and the source character set in translation phase 1 ([5.1.1.2](https://port70.net/~nsz/c/c11/n1570.html#5.1.1.2)).
2. The value of a char object into which has been stored any character other than a member of the basic execution character set ([6.2.5](https://port70.net/~nsz/c/c11/n1570.html#6.2.5)).
3. The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character ([6.4.4.4](https://port70.net/~nsz/c/c11/n1570.html#6.4.4.4)).
4. The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set ([6.4.4.4](https://port70.net/~nsz/c/c11/n1570.html#6.4.4.4)).
5. The current locale used to convert a wide string literal into corresponding wide character codes ([6.4.5](https://port70.net/~nsz/c/c11/n1570.html#6.4.5)).
6. The default state for the FENV_ACCESS pragma ([7.6.1](https://port70.net/~nsz/c/c11/n1570.html#7.6.1)).
7. The default state for the FP_CONTRACT pragma ([7.12.2](https://port70.net/~nsz/c/c11/n1570.html#7.12.2)).