# C11 标准中的 unspecified behavior

## GCC 与 LLVM  的行为一致

### 1. 静态初始化的方式和时间
#### 描述

The manner and timing of static initialization [5.1.2](https://port70.net/~nsz/c/c11/n1570.html#5.1.2).
Two execution environments are defined: freestanding and hosted. In both cases, program startup occurs when a designated C function is called by the execution environment. All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified. Program termination returns control to the execution environment.

定义了两种执行环境：独立式 (freestanding) 和托管式 (hosted)。在这两种情况下，程序启动都是在执行环境调用指定的 C 函数时发生的。所有具有静态存储持续时间的对象都应在程序启动之前初始化（设置为其初始值）。否则未指定这种初始化的方式和时间。程序终止将控制权返回给执行环境。

#### 代码

```c
#include <stdio.h>
static const int x = 5;
static int y = x + 2;
static int z = x + 4;

int main() {
  printf("x = %d, y = %d, z = %d\n", x, y, z); // prints "5 7"
  return 0;
}
```

#### 结果

```bash
$ gcc --std=c11 -ggdb  ./1_static.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./1_static.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
x = 5, y = 7, z = 9
```

经测试，GCC 和 LLVM 的实现没有区别。输出的结果都是 `x = 5, y = 7, z = 9`

### 2. 如果 main 的返回类型与 int 不兼容，则返回到主机环境的终止状态

The termination status returned to the hosted environment if the return type of main is not compatible with int [5.1.2.2.3](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.3).

If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument; reaching the `}` that terminates the main function returns a value of 0. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.

如果 main 函数的返回类型是与 int 兼容的类型，则从初始调用 main 函数返回相当于以 main 函数的返回值作为参数调用 exit 函数；到达 `}` 终止主函数返回值 0。如果返回类型与 int 不兼容，则返回到宿主环境的终止状态是未指定的。

#### 代码

```c
#include <stdio.h>

int main() {
#if defined __clang__
    puts("LLVM:");
#elif defined __GNUC__
    puts("GCC:");
#endif
    char *str = "ss";
    return str;
}
```

##### 结果和分析

`main()` 函数的返回值必须和 int 兼容，否则无法通过编译器的语法检查。

```bash
$ make gcc
gcc --std=c11 2_retrunType.c -o test_gcc
2_retrunType.c: In function ‘main’:
2_retrunType.c:10:12: error: returning ‘char *’ from a function with return type ‘int’ makes integer from pointer without a cast [-Wint-conversion]
   10 |     return str;
      |            ^~~
make: *** [Makefile:12: gcc] Error 1
$ maje clang
clang --std=c11 2_retrunType.c -o test_clang
2_retrunType.c:10:12: error: incompatible pointer to integer conversion returning 'char *' from a function with result type 'int' [-Wint-conversion]
   10 |     return str;
      |            ^~~
1 error generated.
make: *** [Makefile:15: clang] Error
```

### 3. 当抽象机的处理因收到信号而中断时，一些对象的值未指定

#### 描述

The values of objects that are neither lock-free atomic objects nor of type volatile sig_atomic_t and the state of the floating-point environment, when the processing of the abstract machine is interrupted by receipt of a signal [5.1.2.3](https://port70.net/~nsz/c/c11/n1570.html#5.1.2.3).

当抽象机的处理因收到信号而中断时，既不是无锁原子对象也不是 volatile sig_atomic_t 类型的对象的值以及浮点环境的状态

When the processing of the abstract machine is interrupted by receipt of a signal, the values of objects that are neither lock-free atomic objects nor of type volatile sig_atomic_t are unspecified, as is the state of the floating-point environment. The value of any object modified by the handler that is neither a lock-free atomic object nor of type volatile sig_atomic_t becomes indeterminate when the handler exits, as does the state of the floating-point environment if it is modified by the handler and not restored to its original state.

当抽象机的处理因收到信号而中断时，既不是无锁原子对象也不是 `volatile sig_atomic_t` 类型的对象的值是未指定的，浮点环境的状态也是如此。处理程序修改的任何既不是无锁原子对象也不是 `volatile sig_atomic_t` 类型的对象的值在处理程序退出时变得不确定，如果浮点环境被处理程序修改但未恢复到其原始状态，则浮点环境的状态也是如此。

#### 代码

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

float flag = 0;

void signal_handler(int signum) {
    flag += 3;
}

int main() {
    signal(SIGINT, signal_handler);
    while (1) {
        sleep(1);
        printf("flag: %f\n", ++flag);
    }

    return 0;
}
```

#### 结果

```bash
$ make gcc
gcc --std=c11 3_signal.c -o test_gcc
./test_gcc
flag: 1.000000
flag: 2.000000
flag: 3.000000
^Cflag: 7.000000
flag: 8.000000
flag: 9.000000
^Cmake: *** [Makefile:13: gcc] Interrupt

$ make clang
clang --std=c11 3_signal.c -o test_clang
./test_clang
flag: 1.000000
flag: 2.000000
flag: 3.000000
^Cflag: 7.000000
flag: 8.000000
flag: 9.000000
^Cmake: *** [Makefile:16: clang] Interrupt
```

经测试可知，GCC 和 LLVM 的结果保持一致，可以在信号处理函数中正确处理非无锁原子对象也不是 `volatile sig_atomic_t` 类型的对象的值

### 4. 当活动位置位于行末位置时写入打印字符时显示设备的行为

#### 描述

The behavior of the display device if a printing character is written when the active position is at the final position of a line [5.2.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.2).

The active position is that location on a display device where the next character output by the fputc function would appear. The intent of writing a printing character (as defined by the isprint function) to a display device is to display a graphic representation of that character at the active position and then advance the active position to the next position on the current line. The direction of writing is locale-specific. If the active position is at the final position of a line (if there is one), the behavior of the display device is unspecified.

活动位置是显示设备上 `fputc()` 函数输出的下一个字符将出现的位置。将打印字符（由 `isprint` 函数定义）写入显示设备的目的是在活动位置显示该字符的图形表示，然后将活动位置前进到当前行的下一个位置。书写方向是特定于语言环境的。如果活动位置位于一行的最终位置（如果有），则显示设备的行为未指定。

#### 代码

```c
#include <stdio.h>

int main() {
  for (int i = 33; i < 127; ++i) {
    fputc(i, stdout);
  }
  for (int i = 33; i < 127; ++i) {
    fputc(i, stdout);
  }
  for (int i = 33; i < 127; ++i) {
    fputc(i, stdout);
  }
  printf("\n");
  return 0;
}
```

#### 结果

```bash
$ gcc --std=c11 -ggdb  ./4_char.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./4_char.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
```

GCC 和 LLVM 编译后的结果都是自动换行处理，没有差别。

### 5. 当活动位置位于行首位置时写入退格符时显示设备的行为

#### 描述

The behavior of the display device if a backspace character is written when the active position is at the initial position of a line [5.2.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.2).

The active position is that location on a display device where the next character output by the fputc function would appear. The intent of writing a printing character (as defined by the isprint function) to a display device is to display a graphic representation of that character at the active position and then advance the active position to the next position on the current line. The direction of writing is locale-specific. If the active position is at the final position of a line (if there is one), the behavior of the display device is unspecified.

活动位置是显示设备上 `fputc()` 函数输出的下一个字符将出现的位置。将打印字符（由 `isprint` 函数定义）写入显示设备的目的是在活动位置显示该字符的图形表示，然后将活动位置前进到当前行的下一个位置。书写方向是特定于语言环境的。如果活动位置位于一行的最终位置（如果有），则显示设备的行为未指定。

Moves the active position to the previous position on the current line. If the active position is at the initial position of a line, the behavior of the display device is unspecified.

将活动位置移动到当前行的上一个位置。如果活动位置位于一行的初始位置，则显示设备的行为未指定。

#### 代码

```c
#include <stdio.h>

int main(void) {
  fputc('\b', stdout);
  fputc('a', stdout);
  fputc('\n', stdout);
  return 0;
}
```

#### 结果

```bash
$ gcc --std=c11 -ggdb  ./5_background.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./5_background.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
a
```

GCC 和 LLVM 编译后的结果一致

### 6. 当活动位置位于最后定义的水平制表位置或超过该位置时，如果写入水平制表符时的显示设备的行为

#### 描述

The behavior of the display device if a horizontal tab character is written when the active position is at or past the last defined horizontal tabulation position [5.2.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.2).

当活动位置位于最后定义的水平制表位置或超过该位置时，如果写入水平制表符，则显示设备的行为

Moves the active position to the next horizontal tabulation position on the current line. If the active position is at or past the last defined horizontal tabulation position, the behavior of the display device is unspecified.

将活动位置移动到当前行上的下一个水平制表位置。如果活动位置位于或超过最后定义的水平制表位置，则显示设备的行为未指定。

#### 代码

```c
#include <stdio.h>

int main(void) {
  for (int i = 0; i < 100; ++i) {
    fputc('a', stdout);
    fputc('\t', stdout);
  }
  return 0;
}
```

#### 结果

```bash
gcc --std=c11 -ggdb  ./6_tab.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./6_tab.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	aa	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	aa	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	aa	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	
```

GCC 和 LLVM 的表现一致，在长度不够输入制表符时选择不打印制表符。

### 7. 当活动位置位于最后定义的垂直制表位或超过该位置时写入垂直制表符时​​显示设备的行为

#### 描述

The behavior of the display device if a vertical tab character is written when the active position is at or past the last defined vertical tabulation position [5.2.2](https://port70.net/~nsz/c/c11/n1570.html#5.2.2).

当活动位置位于最后定义的垂直制表位或超过该位置时写入垂直制表符时​​显示设备的行为

Moves the active position to the initial position of the next vertical tabulation position. If the active position is at or past the last defined vertical tabulation position, the behavior of the display device is unspecified.

将活动位置移动到下一个垂直制表位置的初始位置。如果活动位置位于或超过最后定义的垂直制表位置，则显示设备的行为未指定。

```c
#include <stdio.h>

int main(void) {
  for (int i = 0; i < 200; ++i) {
    fputc('a', stdout);
    fputc('\v', stdout);
  }
  return 0;
}
```

```bash
$ make cmp

...
                                                                                                                                                                                              a
                                                                                                                                                                                               a
                                                                                                                                                                                                a
                                                                                                                                                                                                 a
                                                                                                                                                                                                  a
                                                                                                                                                                                                   a
                                                                                                                                                                                                    a
                                                                                                                                                                                                     a
                                                                                                                                                                                                      a
                                                                                                                                                                                                       a
                                                                                                                                                                                                        a
                                                                                                                                                                                                         a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a
                                                                                                                                                                                                          a

```

由于整段输出太长，故而节选了可以说明该问题的部分。

GCC 和 LLVM 在该行为实现中没有表现出差别，在没有足够空间让垂直制表符写入时，选择的都是不写入。

### 8. 与通用字符名称不对应的扩展源字符如何计入外部标识符中的有效首字符

#### 描述

How an extended source character that does not correspond to a universal character name counts toward the significant initial characters in an external identifier [5.2.4.1](https://port70.net/~nsz/c/c11/n1570.html#5.2.4.1).

与通用字符名称不对应的扩展源字符如何计入外部标识符中的有效首字符

翻译和执行环境都限制了语言翻译器和库的实现。下面总结了对一致性实现的与语言相关的环境限制。

The implementation shall be able to translate and execute at least one program that contains at least one instance of every one of the following limits:

- 127 nesting levels of blocks
- 63 nesting levels of conditional inclusion
- 12 pointer, array, and function declarators (in any combinations) modifying an arithmetic, structure, union, or void type in a declaration
- 63 nesting levels of parenthesized declarators within a full declarator
- 63 nesting levels of parenthesized expressions within a full expression
- 63 significant initial characters in an internal identifier or a macro name (each universal character name or extended source character is considered a single character)
- 31 significant initial characters in an external identifier (each universal character name specifying a short identifier of 0000FFFF or less is considered 6 characters, each universal character name specifying a short identifier of 00010000 or more is considered 10 characters, and each extended source character is considered the same number of characters as the corresponding universal character name, if any)
- 4095 external identifiers in one translation unit
- 511 identifiers with block scope declared in one block
- 4095 macro identifiers simultaneously defined in one preprocessing translation unit
- 127 parameters in one function definition
- 127 arguments in one function call
- 127 parameters in one macro definition
- 127 arguments in one macro invocation
- 4095 characters in a logical source line
- 4095 characters in a string literal (after concatenation)
- 65535 bytes in an object (in a hosted environment only)
- 15 nesting levels for #included files
- 1023 case labels for a switch statement (excluding those for any nested switch statements)
- 1023 members in a single structure or union
- 1023 enumeration constants in a single enumeration
- 63 levels of nested structure or union definitions in a single struct-declaration-list

该实现应能够翻译和执行至少一个程序，该程序包含以下每一项限制的至少一个实例：

- 127 级块嵌套
- 条件包含的 63 个嵌套级别
- 12 个指针、数组和函数声明符（任意组合），用于修改声明中的算术、结构、联合或 void 类型
- 完整声明符内的括号声明符有 63 层嵌套
- 完整表达式中带括号表达式的 63 层嵌套
- 内部标识符或宏名称中的 63 个重要初始字符（每个通用字符名称或扩展源字符被视为单个字符）
- 外部标识符中的 31 个有效初始字符（指定 0000FFFF 或更小的短标识符的每个通用字符名称被视为 6 个字符，指定 00010000 或更大的短标识符的每个通用字符名称被视为 10 个字符，并且每个扩展源字符被视为与相应的通用角色名称相同的字符数（如果有））
- 一个翻译单元中有 4095 个外部标识符
- 在一个块中声明了 511 个具有块作用域的标识符
- 在一个预处理翻译单元中同时定义 4095 个宏标识符
- 一个函数定义中有 127 个参数
- 一次函数调用中有 127 个参数
- 一个宏定义中有 127 个参数
- 一次宏调用中有 127 个参数
- 逻辑源代码行中有 4095 个字符
- 字符串文字中的 4095 个字符（连接后）
- 对象中 65535 字节（仅在托管环境中）
- #included 文件有 15 个嵌套级别
- switch 语句有 1023 个 case 标签（不包括任何嵌套 switch 语句的标签）
- 单个结构或联盟中有 1023 个成员
- 单个枚举中有 1023 个枚举常量
- 单个结构声明列表中的 63 层嵌套结构或联合定义

```c
#include <stdio.h>

int main(void) {
    int var_扩展字符;
    var_扩展字符 = 0;
    printf("var_扩展字符: %d\n", var_扩展字符);
    return 0;
}
```

GCC 预处理后的结果:

```txt
# 3 "8_exchr.c"
int main(void) {
    int var_\U00006269\U00005c55\U00005b57\U00007b26;
    var_\U00006269\U00005c55\U00005b57\U00007b26 = 0;
    printf("var_扩展字符: %d\n", var_\U00006269\U00005c55\U00005b57\U00007b26);
    return 0;
}
```

LLVM 预处理后的结果:

```txt
# 2 "8_exchr.c" 2

int main(void) {
    int var_扩展字符;
    var_扩展字符 = 0;
    printf("var_扩展字符: %d\n", var_扩展字符);
    return 0;
}
```

经测试，GCC 和 LLVM 都能编译该源代码，"扩展字符" 这四个正常被计入了有效字符，


### 9. 在结构或联合中存储值时填充字节的值

#### 描述

The value of padding bytes when storing values in structures or unions [6.2.6.1](https://port70.net/~nsz/c/c11/n1570.html#6.2.6.1).

在结构或联合中存储值时填充字节的值

When a value is stored in an object of structure or union type, including in a member object, the bytes of the object representation that correspond to any padding bytes take unspecified values. The value of a structure or union object is never a trap representation, even though the value of a member of the structure or union object may be a trap representation.

当值存储在结构或联合类型的对象中（包括成员对象中）时，与任何填充字节对应的对象表示的字节采用未指定的值。结构或联合对象的值永远不是陷阱表示，即使结构或联合对象的成员的值可能是陷阱表示。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct test {
  char a;
  int b;
};

int main(void) {
  struct test test = {'a', 1};
  char *tptr = (char *)malloc(sizeof(struct test));

  printf("sizeof(struct test): %lu\n", sizeof(struct test));
  printf("tptr->a: %c, tptr->b: %d\n", test.a, test.b);
  memcpy(tptr, &test, sizeof(struct test));
  for (int i = 0; i < sizeof(struct test); ++i) {
    printf("curr_ptr: 0x%x, ", &tptr[i]);
    printf("test[%d]: 0x%x\n", i, tptr[i]);
  }
  return 0;
}
```

```bash
$ make cmp
gcc --std=c11 -ggdb  ./10_type_struct.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./10_type_struct.c -o test_clang
./10_type_struct.c:18:32: warning: format specifies type 'unsigned int' but the argument has type 'char *' [-Wformat]
   18 |     printf("curr_ptr: 0x%x, ", &tptr[i]);
      |                         ~~     ^~~~~~~~
      |                         %s
1 warning generated.
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出不一致
sizeof(struct test): 8
tptr->a: a, tptr->b: 1
curr_ptr: 0x2b4c02a0, test[0]: 0x61
curr_ptr: 0x2b4c02a1, test[1]: 0x24
curr_ptr: 0x2b4c02a2, test[2]: 0x2e
curr_ptr: 0x2b4c02a3, test[3]: 0xffffffb9
curr_ptr: 0x2b4c02a4, test[4]: 0x1
curr_ptr: 0x2b4c02a5, test[5]: 0x0
curr_ptr: 0x2b4c02a6, test[6]: 0x0
curr_ptr: 0x2b4c02a7, test[7]: 0x0

sizeof(struct test): 8
tptr->a: a, tptr->b: 1
curr_ptr: 0x478d2a0, test[0]: 0x61
curr_ptr: 0x478d2a1, test[1]: 0x0
curr_ptr: 0x478d2a2, test[2]: 0x0
curr_ptr: 0x478d2a3, test[3]: 0x0
curr_ptr: 0x478d2a4, test[4]: 0x1
curr_ptr: 0x478d2a5, test[5]: 0x0
curr_ptr: 0x478d2a6, test[6]: 0x0
curr_ptr: 0x478d2a7, test[7]: 0x0
```

标准并没有指定填充字节的长度，这里 GCC 和 LLVM 根据代码实际需求将其char 所占空间调整到 int 的大小，并且填充的值都是 0。 


### 10. 与除最后存储的联合成员之外的联合成员相对应的字节值

#### 描述

The values of bytes that correspond to union members other than the one last stored into [6.2.6.1](https://port70.net/~nsz/c/c11/n1570.html#6.2.6.1).

When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take unspecified values.

当值存储在联合类型对象的成员中时，与该成员不对应但与其他成员对应的对象表示形式的字节采用未指定的值。

#### 代码

```c
#include <stdio.h>

union test {
  int i;
  long f;
  char str[20];
};

int main(void) {
  union test test;
  const char *format = "rbp: %lx\nrsp: %lx\n";
  test.str[0] = 'a';

  printf("addr: %lx, test.i: %x\n", &(test.i), test.i);
  printf("addr: %lx, test.f: %lx\n", &(test.f), test.f);
  for (int i = 0; i < sizeof(test.str) / sizeof(char); ++i) {
    printf("test.str[%d]: add: %lx, %hhx\n", i, &(test.str[i]),  test.str[i]);
  };

  __asm__ volatile("mov %rbp, %rsi\n\t"
                   "mov %rsp, %rdx\n\t");
  __asm__ volatile("mov %0, %%rdi" : "+r"(format));
  __asm__ volatile("call printf\n");
  return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb  ./11_union.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./11_union.c -o test_clang
./11_union.c:14:37: warning: format specifies type 'unsigned long' but the argument has type 'int *' [-Wformat]
   14 |   printf("addr: %lx, test.i: %x\n", &(test.i), test.i);
      |                 ~~~                 ^~~~~~~~~
./11_union.c:15:38: warning: format specifies type 'unsigned long' but the argument has type 'long *' [-Wformat]
   15 |   printf("addr: %lx, test.f: %lx\n", &(test.f), test.f);
      |                 ~~~                  ^~~~~~~~~
./11_union.c:17:49: warning: format specifies type 'unsigned long' but the argument has type 'char *' [-Wformat]
   17 |     printf("test.str[%d]: add: %lx, %hhx\n", i, &(test.str[i]), test.str[i]);
      |                                ~~~              ^~~~~~~~~~~~~~
      |                                %s
3 warnings generated.
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出不一致
addr: 7ffe17721fd0, test.i: 61
addr: 7ffe17721fd0, test.f: 61
test.str[0]: add: 7ffe17721fd0, 61
test.str[1]: add: 7ffe17721fd1, 0
test.str[2]: add: 7ffe17721fd2, 0
test.str[3]: add: 7ffe17721fd3, 0
test.str[4]: add: 7ffe17721fd4, 0
test.str[5]: add: 7ffe17721fd5, 0
test.str[6]: add: 7ffe17721fd6, 0
test.str[7]: add: 7ffe17721fd7, 0
test.str[8]: add: 7ffe17721fd8, 0
test.str[9]: add: 7ffe17721fd9, 0
test.str[10]: add: 7ffe17721fda, 0
test.str[11]: add: 7ffe17721fdb, 0
test.str[12]: add: 7ffe17721fdc, 0
test.str[13]: add: 7ffe17721fdd, 0
test.str[14]: add: 7ffe17721fde, 0
test.str[15]: add: 7ffe17721fdf, 0
test.str[16]: add: 7ffe17721fe0, 0
test.str[17]: add: 7ffe17721fe1, 0
test.str[18]: add: 7ffe17721fe2, 0
test.str[19]: add: 7ffe17721fe3, 0
rbp: 7ffe17722000
rsp: 7ffe17721fd0

addr: 7ffd03e05030, test.i: 61
addr: 7ffd03e05030, test.f: 61
test.str[0]: add: 7ffd03e05030, 61
test.str[1]: add: 7ffd03e05031, 0
test.str[2]: add: 7ffd03e05032, 0
test.str[3]: add: 7ffd03e05033, 0
test.str[4]: add: 7ffd03e05034, 0
test.str[5]: add: 7ffd03e05035, 0
test.str[6]: add: 7ffd03e05036, 0
test.str[7]: add: 7ffd03e05037, 0
test.str[8]: add: 7ffd03e05038, a0
test.str[9]: add: 7ffd03e05039, c4
test.str[10]: add: 7ffd03e0503a, 82
test.str[11]: add: 7ffd03e0503b, 5e
test.str[12]: add: 7ffd03e0503c, cb
test.str[13]: add: 7ffd03e0503d, 7f
test.str[14]: add: 7ffd03e0503e, 0
test.str[15]: add: 7ffd03e0503f, 0
test.str[16]: add: 7ffd03e05040, 0
test.str[17]: add: 7ffd03e05041, 0
test.str[18]: add: 7ffd03e05042, 0
test.str[19]: add: 7ffd03e05043, 0
rbp: 7ffd03e05050
rsp: 7ffd03e05020
```

GCC 和 LLVM 对 `union` 中其他没被赋值的成员没有赋额外的值，就是默认为 0，这里对 `test.str` 的中出现非 0 的情况是因为这部分栈空间被用来存储其他变量。

### 11. 两个字符串文字是否产生不同的数组

#### 描述

Whether two string literals result in distinct arrays [6.4.5](https://port70.net/~nsz/c/c11/n1570.html#6.4.5).

两个字符串文字是否产生不同的数组

It is unspecified whether these arrays are distinct provided their elements have the appropriate values. If the program attempts to modify such an array, the behavior is undefined.

如果这些数组的元素具有适当的值，则未指定这些数组是否不同。如果程序尝试修改这样的数组，则行为是未定义的。

#### 代码

```c
#include <stdio.h>
int main(void) {
    char buf_a[256] = "test";
    char buf_b[256] = "test";
    buf_a[0] = 'a';
    printf("buf_a: %s\n", buf_a);
    printf("buf_b: %s\n", buf_b);
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./15_string_array.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./15_string_array.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
buf_a: aest
buf_b: test
```

### 12. 某些运算符是否可以生成负零，以及负零在存储在对象中时是否会变为正常零

#### 描述

Whether certain operators can generate negative zeros and whether a negative zero becomes a normal zero when stored in an object [6.2.6.2](https://port70.net/~nsz/c/c11/n1570.html#6.2.6.2).

It is unspecified whether these cases actually generate a negative zero or a normal zero, and whether a negative zero becomes a normal zero when stored in an object.

未指定这些情况实际上是否生成负零或正常零，以及存储在对象中时负零是否变为正常零。

#### 代码

```c
#include <stdio.h>

int main() {
  int pos_zero = 0;
  int neg_zero = -0;

  printf("0 + -0 = %d\n", pos_zero + neg_zero);
  printf("0 - -0 = %d\n", pos_zero - neg_zero);
  printf("0 * -0 = %d\n", pos_zero * neg_zero);

  return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb  ./14_zero.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./14_zero.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
0 + -0 = 0
0 - -0 = 0
0 * -0 = 0
```

GCC 和 LLVM 的实现无差别，不会产生 `-0` 等形式。

### 13. 复合字面量初始化列表表达式中的副作用顺序

#### 描述

The order of side effects among compound literal initialization list expressions [6.5.2.5](https://port70.net/~nsz/c/c11/n1570.html#6.5.2.5).

复合字面量初始化列表表达式中的副作用顺序未指定

#### 代码

```c
#include <stdio.h>

struct point {
    int x;
    int y;
};

void print_point(struct point p) {
    printf("Point: (%d, %d)\n", p.x, p.y);
}

int main() {
    int x = 1;
    int y = 2;
    print_point((struct point){x++, y++});
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./18_comp_init_order.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./18_comp_init_order.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Point: (1, 2)
```

### 14. 分配用于保存位域的可寻址存储单元的对齐

#### 描述

The alignment of the addressable storage unit allocated to hold a bit-field [6.7.2.1](https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1).

分配用于保存位域的可寻址存储单元的对齐

An implementation may allocate any addressable storage unit large enough to hold a bit- field. If enough space remains, a bit-field that immediately follows another bit-field in a structure shall be packed into adjacent bits of the same unit. If insufficient space remains, whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is implementation-defined. The order of allocation of bit-fields within a unit (high-order to low-order or low-order to high-order) is implementation-defined. The alignment of the addressable storage unit is unspecified.

实现可以分配任何足够大以容纳位字段的可寻址存储单元。如果剩余足够的空间，则结构中紧跟在另一个位字段之后的位字段应被打包到同一单元的相邻位中。如果剩余空间不足，则不适合的位字段是否放入下一个单元或与相邻单元重叠是实现定义的。单元内位字段的分配顺序（高位到低位或低位到高位）是由实现定义的。可寻址存储单元的对齐方式未指定。

#### 代码

```c
#include <stdio.h>
#include <stdint.h>

struct point {
    unsigned int magic : 8;
    unsigned int parity : 1;
    unsigned int stype : 8;
    unsigned int sid : 8;
    unsigned int message : 8;
};

int main() {
    struct point ipoint;
    ipoint.magic = 255;
    ipoint.parity = 1;
    ipoint.stype = 255;
    ipoint.sid = 255;
    ipoint.message = 255;

    char *buf = (char*)&ipoint;
    for (int i = 0; i < sizeof(ipoint); ++i) {
        printf("buf[%d]: %x\n", i, buf[i]);
    }
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./20_bit.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./20_bit.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
buf[0]: ffffffff
buf[1]: ffffffff
buf[2]: ffffffff
buf[3]: 1
buf[4]: ffffffff
buf[5]: 0
buf[6]: 0
buf[7]: 
```

### 15. feraiseexcept 引发浮点异常的顺序，除非在 F.8.6 中另有说明

#### 描述

The order in which feraiseexcept raises floating-point exceptions, except as stated in F.8.6 [7.6.2.3](https://port70.net/~nsz/c/c11/n1570.html#7.6.2.3).

`feraiseexcept` 函数尝试触发其参数所表示的支持的浮点异常。除了在 F.8.6 小节中明确规定的情况外，这些浮点异常的引发顺序未指定。此外，当 `feraiseexcept` 函数引发 “overflow” 或 “underflow” 浮点异常时，它是否会同时引发 “inexact” 浮点异常，是由实现（如编译器或平台）决定的，因此不同的实现可能会有不同的行为。


#### 代码

```c
#include <stdio.h>
#include <fenv.h>

void check_exceptions() {
    if (fetestexcept(FE_OVERFLOW)) {
        printf("Overflow exception detected.\n");
    }
    if (fetestexcept(FE_UNDERFLOW)) {
        printf("Underflow exception detected.\n");
    }
    if (fetestexcept(FE_INEXACT)) {
        printf("Inexact exception detected.\n");
    }
}

int main() {
    feclearexcept(FE_ALL_EXCEPT);

    feraiseexcept(FE_OVERFLOW | FE_INEXACT);
    printf("After raising FE_OVERFLOW | FE_INEXACT:\n");
    check_exceptions();

    feclearexcept(FE_ALL_EXCEPT);

    feraiseexcept(FE_UNDERFLOW | FE_INEXACT);
    printf("\nAfter raising FE_UNDERFLOW | FE_INEXACT:\n");
    check_exceptions();

    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./28_fexp.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./28_fexp.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
After raising FE_OVERFLOW | FE_INEXACT:
Overflow exception detected.
Inexact exception detected.

After raising FE_UNDERFLOW | FE_INEXACT:
Underflow exception detected.
Inexact exception detected.
```

### 16. math_errhandling 是否是宏或具有外部链接的标识符

#### 描述

Whether math_errhandling is a macro or an identifier with external linkage [7.12](https://port70.net/~nsz/c/c11/n1570.html#7.12).

math_errhandling 是否是宏或具有外部链接的标识符

#### 代码

```c
#include <stdio.h>
#include <math.h>

#ifdef math_errhandling
#define MATH_ERRHANDLING_IS_MACRO 1
#else
#define MATH_ERRHANDLING_IS_MACRO 0
#endif

int main() {
    printf("MATH_ERRHANDLING_IS_MACRO: %d\n", MATH_ERRHANDLING_IS_MACRO);
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./29_math_err_macro.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./29_math_err_macro.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
MATH_ERRHANDLING_IS_MACRO: 1
```

GCC 和 LLVM 的实现一致，都将 `math_errhandling` 实现成了一个宏

### 17. 当指定值不是浮点数时，frexp 函数的结果

#### 描述

The results of the frexp functions when the specified value is not a floating-point number [7.12.6.4](https://port70.net/~nsz/c/c11/n1570.html#7.12.6.4).

当指定值不是浮点数时，`frexp` 函数的结果

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <limits.h>
#include <float.h>

void test_frexp(double value) {
    int exp;
    double result = frexp(value, &exp);

    printf("Testing value: %g\n", value);
    printf("Result: %g, Exponent: %d\n", result, exp);
    printf("Reconstructed value: %g\n", result * pow(2, exp));

    if (isinf(value)) {
        printf("Value is infinity.\n");
    } else if (isnan(value)) {
        printf("Value is NaN.\n");
    } else if (exp > INT_MAX || exp < INT_MIN) {
        printf("Exponent is outside the range of int.\n");
    } else {
        printf("Result is within expected bounds.\n");
    }
    printf("\n");
}

int main() {
    test_frexp(8.0);
    test_frexp(0.5);
    test_frexp(DBL_MAX);
    test_frexp(DBL_MIN);
    test_frexp(NAN);
    test_frexp(INFINITY);
    test_frexp(-INFINITY);
    test_frexp(0.0);
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./30_frexp.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./30_frexp.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Testing value: 8
Result: 0.5, Exponent: 4
Reconstructed value: 8
Result is within expected bounds.

Testing value: 0.5
Result: 0.5, Exponent: 0
Reconstructed value: 0.5
Result is within expected bounds.

Testing value: 1.79769e+308
Result: 1, Exponent: 1024
Reconstructed value: inf
Result is within expected bounds.

Testing value: 2.22507e-308
Result: 0.5, Exponent: -1021
Reconstructed value: 2.22507e-308
Result is within expected bounds.

Testing value: nan
Result: nan, Exponent: 0
Reconstructed value: nan
Value is NaN.

Testing value: inf
Result: inf, Exponent: 0
Reconstructed value: inf
Value is infinity.

Testing value: -inf
Result: -inf, Exponent: 0
Reconstructed value: -inf
Value is infinity.

Testing value: 0
Result: 0, Exponent: 0
Reconstructed value: 0
Result is within expected bounds.
```

GCC 和 LLVM 的实现一致

### 18. 当正确值超出返回类型范围时，ilogb 函数的数值结果

#### 描述

The numeric result of the ilogb functions when the correct value is outside the range of the return type [7.12.6.5](https://port70.net/~nsz/c/c11/n1570.html#7.12.6.5), [F.10.3.5](https://port70.net/~nsz/c/c11/n1570.html#F.10.3.5).

`ilogb` 函数将 `x` 的指数提取为有符号的 int 值。如果 `x` 为零，则计算值 `FP_ILOGB0`；如果 `x` 为无穷大，则计算值 `INT_MAX`；如果 `x` 为 `NaN`，则计算值 `FP_ILOGBNAN`；否则，它们相当于调用相应的 `logb` 函数并将返回值转换为 int 类型。如果 `x` 为零、无穷大或 `NaN`，则可能出现域错误或范围错误。如果正确值超出返回类型的范围，则数字结果未指定。

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <limits.h>

void test_ilogb(double x) {
    int result = ilogb(x);
    printf("ilogb(%g) = %d\n", x, result);

    if (result == FP_ILOGB0) {
        printf("Result is FP_ILOGB0 (x is zero)\n");
    } else if (result == INT_MAX) {
        printf("Result is INT_MAX (x is infinite)\n");
    } else if (result == FP_ILOGBNAN) {
        printf("Result is FP_ILOGBNAN (x is NaN)\n");
    } else if (result == INT_MIN) {
        printf("Result is INT_MIN (potential underflow or error)\n");
    } else if (result > INT_MAX || result < INT_MIN) {
        printf("Result is outside the range of int (unspecified behavior)\n");
    } else {
        printf("Result is within the expected range of int\n");
    }
    printf("\n");
}

int main() {
    test_ilogb(8.0);
    test_ilogb(0.5);
    test_ilogb(DBL_MAX);
    test_ilogb(DBL_MIN);
    test_ilogb(0.0);
    test_ilogb(INFINITY);
    test_ilogb(-INFINITY);
    test_ilogb(NAN);
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./31_ilogb.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./31_ilogb.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
ilogb(8) = 3
Result is within the expected range of int

ilogb(0.5) = -1
Result is within the expected range of int

ilogb(1.79769e+308) = 1023
Result is within the expected range of int

ilogb(2.22507e-308) = -1022
Result is within the expected range of int

ilogb(0) = -2147483648
Result is FP_ILOGB0 (x is zero)

ilogb(inf) = 2147483647
Result is INT_MAX (x is infinite)

ilogb(-inf) = 2147483647
Result is INT_MAX (x is infinite)

ilogb(nan) = -2147483648
Result is FP_ILOGB0 (x is zero)
```

GCC 和 LLVM 的实现一致

### 19. 数值超出范围时的舍入结果

#### 描述

The result of rounding when the value is out of range [7.12.9.5](https://port70.net/~nsz/c/c11/n1570.html#7.12.9.5), [7.12.9.7](https://port70.net/~nsz/c/c11/n1570.html#7.12.9.7), [F.10.6.5](https://port70.net/~nsz/c/c11/n1570.html#F.10.6.5).

The `lrint` and `llrint` functions round their argument to the nearest integer value, rounding according to the current rounding direction. If the rounded value is outside the range of the return type, the numeric result is unspecified and a domain error or range error may occur. 

`lrint` 和 `llrint` 函数将其参数四舍五入为最接近的整数值，并根据当前的舍入方向进行舍入。如果舍入的值超出返回类型的范围，则数字结果未指定，并且可能会发生域错误或范围错误。

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <errno.h>
#include <limits.h>

void test_lrint(double x) {
    errno = 0;
    long int result = lrint(x);

    printf("lrint(%g) = %ld\n", x, result);

    if (errno == ERANGE) {
        printf("Range error occurred\n");
    } else if (errno == EDOM) {
        printf("Domain error occurred\n");
    } else if (result == LONG_MAX || result == LONG_MIN) {
        printf("Result is at the edge of the long int range\n");
    } else if (result > LONG_MAX || result < LONG_MIN) {
        printf("Result is outside the range of long int (unspecified behavior)\n");
    } else {
        printf("Result is within the expected range\n");
    }
    printf("\n");
}

void test_llrint(double x) {
    errno = 0;
    long long int result = llrint(x);

    printf("llrint(%g) = %lld\n", x, result);

    if (errno == ERANGE) {
        printf("Range error occurred\n");
    } else if (errno == EDOM) {
        printf("Domain error occurred\n");
    } else if (result == LLONG_MAX || result == LLONG_MIN) {
        printf("Result is at the edge of the long long int range\n");
    } else if (result > LLONG_MAX || result < LLONG_MIN) {
        printf("Result is outside the range of long long int (unspecified behavior)\n");
    } else {
        printf("Result is within the expected range\n");
    }
    printf("\n");
}

int main() {
    test_lrint(8.0);
    test_llrint(8.0);
    test_lrint(LONG_MAX);
    test_llrint(LLONG_MAX);
    test_lrint(LONG_MIN);
    test_llrint(LLONG_MIN);
    test_lrint((double)LONG_MAX * 2.0);
    test_llrint((double)LLONG_MAX * 2.0);
    test_lrint((double)LONG_MIN * 2.0);
    test_llrint((double)LLONG_MIN * 2.0);

    return 0;
}
```

#### 结果

```bash
make cmp
gcc --std=c11 -ggdb -lm ./32_number.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./32_number.c -o test_clang
./32_number.c:51:16: warning: implicit conversion from 'long' to 'double' changes value from 9223372036854775807 to 9223372036854775808 [-Wimplicit-const-int-float-conversion]
   51 |     test_lrint(LONG_MAX);
      |     ~~~~~~~~~~ ^~~~~~~~
/usr/lib/clang/18/include/limits.h:47:19: note: expanded from macro 'LONG_MAX'
   47 | #define LONG_MAX  __LONG_MAX__
      |                   ^~~~~~~~~~~~
<built-in>:61:22: note: expanded from macro '__LONG_MAX__'
   61 | #define __LONG_MAX__ 9223372036854775807L
      |                      ^~~~~~~~~~~~~~~~~~~~
./32_number.c:52:17: warning: implicit conversion from 'long long' to 'double' changes value from 9223372036854775807 to 9223372036854775808 [-Wimplicit-const-int-float-conversion]
   52 |     test_llrint(LLONG_MAX);
      |     ~~~~~~~~~~~ ^~~~~~~~~
/usr/lib/clang/18/include/limits.h:105:20: note: expanded from macro 'LLONG_MAX'
  105 | #define LLONG_MAX  __LONG_LONG_MAX__
      |                    ^~~~~~~~~~~~~~~~~
<built-in>:62:27: note: expanded from macro '__LONG_LONG_MAX__'
   62 | #define __LONG_LONG_MAX__ 9223372036854775807LL
      |                           ^~~~~~~~~~~~~~~~~~~~~
2 warnings generated.
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
lrint(8) = 8
Result is within the expected range

llrint(8) = 8
Result is within the expected range

lrint(9.22337e+18) = -9223372036854775808
Result is at the edge of the long int range

llrint(9.22337e+18) = -9223372036854775808
Result is at the edge of the long long int range

lrint(-9.22337e+18) = -9223372036854775808
Result is at the edge of the long int range

llrint(-9.22337e+18) = -9223372036854775808
Result is at the edge of the long long int range

lrint(1.84467e+19) = -9223372036854775808
Result is at the edge of the long int range

llrint(1.84467e+19) = -9223372036854775808
Result is at the edge of the long long int range

lrint(-1.84467e+19) = -9223372036854775808
Result is at the edge of the long int range

llrint(-1.84467e+19) = -9223372036854775808
Result is at the edge of the long long int range
```

GCC 和 LLVM 的行为一致

### 20. 当 y 为零时，remquo 存储的值在 quo 指向的对象的值

#### 描述

The value stored by the remquo functions in the object pointed to by quo when y is zero [7.12.10.3](https://port70.net/~nsz/c/c11/n1570.html#7.12.10.3).

remquo 函数计算的余数与求余函数相同。它们在 quo 指向的对象中存储一个值，该值的符号为 x/y 的符号，其大小与 x/y 的整数商的大小模 2n 一致，其中 n 是大于或等于 3 的实现定义的整数。

remquo 函数返回 x REM y。如果 y 为零，则 quo 指向的对象中存储的值未指定，是否发生域错误或函数返回零由实现定义。

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <errno.h>

void test_remquo(double x, double y) {
    int quo;
    errno = 0;
    double result = remquo(x, y, &quo);

    printf("remquo(%g, %g, &quo) = %g\n", x, y, result);
    printf("quo = %d\n", quo);

    if (errno == ERANGE) {
        printf("Range error occurred\n");
    } else if (errno == EDOM) {
        printf("Domain error occurred\n");
    } else {
        printf("No error occurred\n");
    }

    if (y == 0) {
        printf("Testing with y = 0, behavior is implementation-defined\n");
    }
    printf("\n");
}

int main() {
    test_remquo(10.0, 3.0);
    test_remquo(10.0, 0.0);
    test_remquo(-10.0, 0.0);
    test_remquo(0.0, 0.0);
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./33_remquo.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./33_remquo.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
remquo(10, 3, &quo) = 1
quo = 3
No error occurred

remquo(10, 0, &quo) = -nan
quo = 3
No error occurred
Testing with y = 0, behavior is implementation-defined

remquo(-10, 0, &quo) = -nan
quo = 3
No error occurred
Testing with y = 0, behavior is implementation-defined

remquo(0, 0, &quo) = -nan
quo = 3
No error occurred
Testing with y = 0, behavior is implementation-defined
```

### 21. 以比其语义类型更宽的格式表示的比较参数是否转换为语义类型

#### 描述

Whether a comparison macro argument that is represented in a format wider than its semantic type is converted to the semantic type [7.12.14](https://port70.net/~nsz/c/c11/n1570.html#7.12.14).

以比其语义类型更宽的格式表示的比较参数是否转换为语义类型

#### 代码

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    uint64_t large_value = UINT64_MAX;
    printf("large_value > 1: %d\n", large_value > 1);
    return 0;
}
```

#### 结果

```bash
$ make gcc
gcc --std=c11 -ggdb ./34_wid.c -o test_gcc
./test_gcc > gcc_out
$ make clang
clang --std=c11 -ggdb ./34_wid.c -o test_clang
./test_clang > clang_out
$ objdump --disassemble=main test_gcc

test_gcc:     file format elf64-x86-64


Disassembly of section .init:

Disassembly of section .plt:

Disassembly of section .text:

0000000000001139 <main>:
    1139:	55                   	push   %rbp
    113a:	48 89 e5             	mov    %rsp,%rbp
    113d:	48 83 ec 10          	sub    $0x10,%rsp
    1141:	48 c7 45 f8 ff ff ff 	movq   $0xffffffffffffffff,-0x8(%rbp)
    1148:	ff 
    1149:	48 83 7d f8 01       	cmpq   $0x1,-0x8(%rbp)
    114e:	0f 97 c0             	seta   %al
    1151:	0f b6 c0             	movzbl %al,%eax
    1154:	89 c6                	mov    %eax,%esi
    1156:	48 8d 05 a7 0e 00 00 	lea    0xea7(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    115d:	48 89 c7             	mov    %rax,%rdi
    1160:	b8 00 00 00 00       	mov    $0x0,%eax
    1165:	e8 c6 fe ff ff       	call   1030 <printf@plt>
    116a:	b8 00 00 00 00       	mov    $0x0,%eax
    116f:	c9                   	leave
    1170:	c3                   	ret

Disassembly of section .fini:

$ objdump --disassemble=main test_clang

test_clang:     file format elf64-x86-64


Disassembly of section .init:

Disassembly of section .plt:

Disassembly of section .text:

0000000000001140 <main>:
    1140:	55                   	push   %rbp
    1141:	48 89 e5             	mov    %rsp,%rbp
    1144:	48 83 ec 10          	sub    $0x10,%rsp
    1148:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    114f:	48 c7 45 f0 ff ff ff 	movq   $0xffffffffffffffff,-0x10(%rbp)
    1156:	ff 
    1157:	48 83 7d f0 01       	cmpq   $0x1,-0x10(%rbp)
    115c:	0f 97 c0             	seta   %al
    115f:	24 01                	and    $0x1,%al
    1161:	0f b6 f0             	movzbl %al,%esi
    1164:	48 8d 3d 99 0e 00 00 	lea    0xe99(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>
    116b:	b0 00                	mov    $0x0,%al
    116d:	e8 be fe ff ff       	call   1030 <printf@plt>
    1172:	31 c0                	xor    %eax,%eax
    1174:	48 83 c4 10          	add    $0x10,%rsp
    1178:	5d                   	pop    %rbp
    1179:	c3                   	ret

Disassembly of section .fini:
```

从 test_gcc 和 test_clang 的汇编表示可以看出，当宽度不一致时，会转为更宽的那个，所以这里都使用 `cmpq` 做运算。

### 22. setjmp 是宏还是具有外部链接的标识符

#### 描述

Whether setjmp is a macro or an identifier with external linkage [7.13](https://port70.net/~nsz/c/c11/n1570.html#7.13).

是否 `setjmp` 是一个宏还是一个具有外部链接的标识符是未指定的。如果为了访问实际的函数而抑制宏定义，或者如果程序定义了一个名为 `setjmp` 的外部标识符，则行为是未定义的。

#### 代码

```c
#include <stdio.h>
#include <setjmp.h>

#ifdef setjmp
#define SETJMP_IS_MACRO 1
#else
#define SETJMP_IS_MACRO 0
#endif

int main() {
    printf("SETJMP_IS_MACRO: %d\n", SETJMP_IS_MACRO);
    return 0;
}
```

#### 结果

```bash
make cmp
gcc --std=c11 -ggdb ./35_setjmp.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./35_setjmp.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
SETJMP_IS_MACRO: 1
```

### 23. `va_copy` 和 `va_end` 是否是宏或具有外部链接的标识符

#### 描述

Whether va_copy and va_end are macros or identifiers with external linkage [7.16.1](https://port70.net/~nsz/c/c11/n1570.html#7.16.1).

`va_copy` 和 `va_end` 是否是宏或具有外部链接的标识符

#### 代码

```c
#include <stdio.h>
#include <stdarg.h>

#ifdef va_copy
#define VA_COPY_IS_MACRO 1
#else
#define VA_COPY_IS_MACRO 0
#endif

#ifdef va_end
#define VA_END_IS_MACRO 1
#else
#define VA_END_IS_MACRO 0
#endif

int main() {
    printf("VA_COPY_IS_MACRO: %d, VA_END_IS_MACRO: %d\n", VA_COPY_IS_MACRO, VA_END_IS_MACRO);
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./36_vautil.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./36_vautil.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
VA_COPY_IS_MACRO: 1, VA_END_IS_MACRO: 1
```

### 24. 使用 a 或  A 转换说明符打印非规范化浮点数时小数点前的十六进制数字

#### 描述

The hexadecimal digit before the decimal point when a non-normalized floating-point number is printed with an a or A conversion specifier [7.21.6.1](https://port70.net/~nsz/c/c11/n1570.html#7.21.6.1), [7.29.2.1](https://port70.net/~nsz/c/c11/n1570.html#7.29.2.1).

使用 a 或  A 转换说明符打印非规范化浮点数时小数点前的十六进制数字

#### 代码

```c
#include <stdio.h>
#include <float.h>

void test_format(double value, const char* format) {
    printf("Testing format: %s ", format);
    printf(format, value);
    printf("\n");
}

int main() {
    double values[] = {0.0, 1.0, 2.0, 3.141592653589793, DBL_MAX, DBL_MIN};
    const char* formats[] = {"%a", "%A"};
    for (int i = 0; i < sizeof(values) / sizeof(values[0]); ++i) {
        for (int j = 0; j < sizeof(formats) / sizeof(formats[0]); ++j) {
            test_format(values[i], formats[j]);
        }
    }
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./37_fprintf.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./37_fprintf.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Testing format: %a 0x0p+0
Testing format: %A 0X0P+0
Testing format: %a 0x1p+0
Testing format: %A 0X1P+0
Testing format: %a 0x1p+1
Testing format: %A 0X1P+1
Testing format: %a 0x1.921fb54442d18p+1
Testing format: %A 0X1.921FB54442D18P+1
Testing format: %a 0x1.fffffffffffffp+1023
Testing format: %A 0X1.FFFFFFFFFFFFFP+1023
Testing format: %a 0x1p-1022
Testing format: %A 0X1P-1022
```

### 25. 成功调用文本流的 `ungetc` 函数或任何流的 `ungetwc` 函数后，文件位置指示器的值，直到所有推回的字符都被读取或丢弃

#### 描述

The value of the file position indicator after a successful call to the ungetc function for a text stream, or the ungetwc function for any stream, until all pushed-back characters are read or discarded [7.21.7.10](https://port70.net/~nsz/c/c11/n1570.html#7.21.7.10), [7.29.3.10](https://port70.net/~nsz/c/c11/n1570.html#7.29.3.10).

成功调用文本流的 `ungetc` 函数或任何流的 `ungetwc` 函数后，文件位置指示器的值，直到所有推回的字符都被读取或丢弃

对 `ungetc` 函数的成功调用会清除该流的文件末尾指示器。读取或丢弃所有推回字符后，流的文件位置指示器的值应当与推回字符之前的值相同。对于文本流，在成功调用 `ungetc` 函数后，直到所有推回字符被读取或丢弃之前，其文件位置指示器的值是未指定的。对于二进制流，其文件位置指示器在每次成功调用 `ungetc` 函数时会减少；如果调用前其值为零，则调用后其值是不确定的。

对 `ungetwc` 函数的成功调用会清除该流的文件末尾指示器。读取或丢弃所有推回的宽字符后，流的文件位置指示器的值应当与推回宽字符之前的值相同。对于文本流或二进制流，在成功调用 `ungetwc` 函数后，直到所有推回的宽字符被读取或丢弃之前，其文件位置指示器的值是未指定的。

#### 代码

```c
#include <stdio.h>
#include <stdlib.h>

void test_text_stream() {
    FILE *file = tmpfile();
    if (!file) {
        perror("tmpfile");
        exit(EXIT_FAILURE);
    }

    fprintf(file, "hello");
    rewind(file);

    int c = fgetc(file);
    if (c != EOF) {
        ungetc(c, file);
    }

    printf("Testing text stream:\n");
    fseek(file, 0, SEEK_CUR);
    long pos = ftell(file);
    printf("File position before reading pushed-back character: %ld\n", pos);

    c = fgetc(file);
    if (c != EOF) {
        printf("Read character: %c\n", (char)c);
    }
    fseek(file, 0, SEEK_CUR);
    pos = ftell(file);
    printf("File position after reading pushed-back character: %ld\n", pos);

    fclose(file);
}

void test_binary_stream() {
    FILE *file = tmpfile();
    if (!file) {
        perror("tmpfile");
        exit(EXIT_FAILURE);
    }

    fputs("binarydata", file);
    rewind(file);

    int c = fgetc(file);
    if (c != EOF) {
        ungetc(c, file);
    }

    printf("Testing binary stream:\n");
    fseek(file, 0, SEEK_CUR);
    long pos = ftell(file);
    printf("File position before reading pushed-back character: %ld\n", pos);

    c = fgetc(file);
    if (c != EOF) {
        printf("Read character: %c\n", (char)c);
    }
    fseek(file, 0, SEEK_CUR);
    pos = ftell(file);
    printf("File position after reading pushed-back character: %ld\n", pos);

    fclose(file);
}

int main() {
    test_text_stream();
    test_binary_stream();
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./38_ungetc.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./38_ungetc.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Testing text stream:
File position before reading pushed-back character: 0
Read character: h
File position after reading pushed-back character: 1
Testing binary stream:
File position before reading pushed-back character: 0
Read character: b
File position after reading pushed-back character: 1
```

### 26. `fgetpos` 函数存储的值的详细信息

#### 描述

The details of the value stored by the fgetpos function [7.21.9.1](https://port70.net/~nsz/c/c11/n1570.html#7.21.9.1).
    - The fgetpos function stores the current values of the parse state (if any) and file position indicator for the stream pointed to by stream in the object pointed to by pos. The values stored contain unspecified information usable by the fsetpos function for repositioning the stream to its position at the time of the call to the fgetpos function. 

`fpos_t` 类型是一个结构体，在 glibc 中是这样:

```c
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
```

具体存储的信息由 libc 实现，所以 GCC 和 LLVM 编译器的表现一致。

### 27. `ftell` 函数对文本流返回的值的详细信息

#### 描述

The details of the value returned by the ftell function for a text stream [7.21.9.4](https://port70.net/~nsz/c/c11/n1570.html#7.21.9.4).

ftell 函数获取stream 指向的流的文件位置指示符的当前值。对于二进制流，该值是从文件开头算起的字符数。对于文本流，其文件位置指示符包含未指定的信息

`ftell` 的返回值属于 libc 实现的部分，不属于 GCC 和 LLVM 之间的差异性比较。GCC 和 LLVM 编译出的程序行为一致。

### 28. `strtod`、`strtof`、`strtold`、`wcstod`、`wcstof` 和 `wcstold` 相关

#### 描述

Whether the strtod, strtof, strtold, wcstod, wcstof, and wcstold functions convert a minus-signed sequence to a negative number directly or by negating the value resulting from converting the corresponding unsigned sequence [7.22.1.3](https://port70.net/~nsz/c/c11/n1570.html#7.22.1.3), [7.29.4.1.1](https://port70.net/~nsz/c/c11/n1570.html#7.29.4.1.1).

strtod、strtof、strtold、wcstod、wcstof 和 wcstold 函数是否直接将负号序列转换为负数，还是通过对转换相应的无符号序列所得的值取反。

该行为是对库函数的描述，与 GCC 和 LLVM 之间的差异无关。所以 GCC 和 LLVM 编译后的结果的行为一致。

### 29. 通过连续调用 `calloc`、`malloc` 和 `realloc` 函数分配的存储顺序和连续性

#### 描述

The order and contiguity of storage allocated by successive calls to the calloc, malloc, and realloc functions [7.22.3](https://port70.net/~nsz/c/c11/n1570.html#7.22.3).

通过连续调用 calloc、malloc 和 realloc 函数分配的存储顺序和连续性

该行为是对库函数的描述，与 GCC 和 LLVM 之间的差异无关。所以 GCC 和 LLVM 编译后的结果的行为一致。

### 30. 当请求的字节数为 0 时，成功调用 calloc、malloc 或 realloc 函数所分配的存储量

#### 描述

The amount of storage allocated by a successful call to the calloc, malloc, or realloc function when 0 bytes was requested [7.22.3](https://port70.net/~nsz/c/c11/n1570.html#7.22.3).

当请求的字节数为 0 时，成功调用 calloc、malloc 或 realloc 函数所分配的存储量

该行为是对库函数的描述，与 GCC 和 LLVM 之间的差异无关。所以 GCC 和 LLVM 编译后的结果的行为一致。

### 31. 在 `exit` 函数调用之前未发生的 `atexit` 函数调用是否会成功

#### 描述

Whether a call to the atexit function that does not happen before the exit function is called will succeed [7.22.4.2](https://port70.net/~nsz/c/c11/n1570.html#7.22.4.2).

在 exit 函数调用之前未发生的 atexit 函数调用是否会成功

#### 代码

```c
#include <stdio.h>
#include <stdlib.h>

void cleanup(void) { printf("Cleanup function called.\n"); }

int main(void) {
  exit(EXIT_SUCCESS);
  if (atexit(cleanup) != 0) {
    printf("Failed to register cleanup function.\n");
  }
  return 0;
}
```

#### 结果

```bash
make cmp
gcc --std=c11 -ggdb ./44_exit.c  -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./44_exit.c  -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
```

### 32. 在 `quick_exit` 函数调用之前未发生的 `at_quick_exit` 函数调用是否会成功

#### 描述

Whether a call to the at_quick_exit function that does not happen before the quick_exit function is called will succeed [7.22.4.3](https://port70.net/~nsz/c/c11/n1570.html#7.22.4.3).

在 `quick_exit` 函数调用之前未发生的 `at_quick_exit` 函数调用是否会成功

The at_quick_exit function registers the function pointed to by func, to be called without arguments should quick_exit be called. It is unspecified whether a call to the at_quick_exit function that does not happen before the quick_exit function is called will succeed.

`at_quick_exit` 函数注册了 `func` 指向的函数，如果调用 `quick_exit`，则在不带参数的情况下调用。未指定在调用 `quick_exit` 函数之前未发生的对 `at_quick_exit` 函数的调用是否会成功。

#### 代码

```c
#include <stdio.h>
#include <stdlib.h>

void cleanup(void) { printf("Cleanup function called.\n"); }

int main(void) {
  quick_exit(EXIT_SUCCESS);
  if (at_quick_exit(cleanup) != 0) {
    printf("Failed to register cleanup function.\n");
  }
  return 0;
}
```

#### 结果

```bash
make cmp
gcc --std=c11 -ggdb ./45_quick_exit.c  -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./45_quick_exit.c  -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
```

GCC 和 LLVM 的输出是一致的，且都是没有调用成功。

### 33. 两个相等的元素中，哪一个与 `bsearch` 函数匹配

#### 描述

Which of two elements that compare as equal is matched by the bsearch function [7.22.5.1](https://port70.net/~nsz/c/c11/n1570.html#7.22.5.1).

两个相等的元素中，哪一个与 bsearch 函数匹配

The bsearch function returns a pointer to a matching element of the array, or a null pointer if no match is found. If two elements compare as equal, which element is matched is unspecified. 

从标准原文中可知，这里是指两个元素相等的情况下匹配到的值未指定。但这并不会影响运算结果。

### 34. 数组中两个元素按 `qsort` 函数排序后的顺序相等

#### 描述

The order of two elements that compare as equal in an array sorted by the qsort function [7.22.5.2](https://port70.net/~nsz/c/c11/n1570.html#7.22.5.2).

数组中两个元素按 qsort 函数排序后的顺序相等

If two elements compare as equal, their order in the resulting sorted array is unspecified. 

从标准原文中可知，这里是指两个元素相等的情况下顺序未指定。但这并不会影响运算结果。

### 35. `time` 函数返回的日历时间的编码

#### 描述

The encoding of the calendar time returned by the time function [7.27.2.4](https://port70.net/~nsz/c/c11/n1570.html#7.27.2.4).

time 函数返回的日历时间的编码

#### 代码

```c
#include <stdio.h>
#include <string.h>
#include <time.h>
int main(void) {
  struct timespec test;
  time_t start = time(NULL);
  char buf[sizeof(start)];
  memcpy(buf, &start, sizeof(start));
  for (int i = 0; i < sizeof(buf); ++i) {
    printf("%x", buf[i]);
  }
  puts("");
  return 0;
}
```

#### 结果

```bash
$ make gcc
gcc --std=c11 -ggdb ./48_time_en.c  -o test_gcc
./test_gcc
291bffffffac660000
$ make clang
clang --std=c11 -ggdb ./48_time_en.c  -o test_clang
./test_clang
2b1bffffffac660000
```

GCC 和 LLVM 对 `time_t` 的编码方式一致。

### 36. 如果转换的任何时间值超出正常范围，则 `strftime` 或 `wcsftime` 函数存储的字符

#### 描述

The characters stored by the strftime or wcsftime function if any of the time values being converted is outside the normal range [7.27.3.5](https://port70.net/~nsz/c/c11/n1570.html#7.27.3.5), [7.29.5.1](https://port70.net/~nsz/c/c11/n1570.html#7.29.5.1).

If the total number of resulting characters including the terminating null character is not more than maxsize, the strftime function returns the number of characters placed into the array pointed to by s not including the terminating null character. Otherwise, zero is returned and the contents of the array are indeterminate. 

这里说的是存储的 `buffer` 的大小范围小于要转换的时间值，则 `buffer` 的内容未指定

#### 代码

```c
// 49_strftime.c
#include <stdio.h>
#include <time.h>

int main() {
  char buffer[10];
  struct tm time_info;

  time_info.tm_year = 2024 - 1900;
  time_info.tm_mon = 13;
  time_info.tm_mday = 15;
  time_info.tm_hour = 10;
  time_info.tm_min = 30;
  time_info.tm_sec = 0;
  time_info.tm_isdst = -1;

  strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", &time_info);

  printf("time: %s\n", buffer);

  return 0;
}
```

```c
// 49_wcsftime.c
#include <locale.h>
#include <stdio.h>
#include <time.h>
#include <wchar.h>

int main() {
  wchar_t buffer[10];
  struct tm time_info;

  setlocale(LC_ALL, "");

  time_info.tm_year = 2024 - 1900;
  time_info.tm_mon = 6;
  time_info.tm_mday = 10000000;
  time_info.tm_hour = 10;
  time_info.tm_min = 30;
  time_info.tm_sec = 0;
  time_info.tm_isdst = -1;

  size_t result = wcsftime(buffer, sizeof(buffer) / sizeof(wchar_t),
                           L"%Y-%m-%d %H:%M:%S", &time_info);

  if (result == 0) {
    wprintf(L"indeterminate time: %ls\n", buffer);
  } else {
    wprintf(L"time: %ls\n", buffer);
  }

  return 0;
}
```

#### 结果

```bash
$ make gcc
gcc --std=c11 -ggdb ./49_strftime.c  -o test_gcc
./test_gcc
time: 2024-14-

$ make clang
clang --std=c11 -ggdb ./49_strftime.c  -o test_clang
./test_clang
time: 2024-14-
```

GCC 和 LLVM 的行为一致，都是将能存储的部分转换完。

```bash
$ make gcc
gcc --std=c11 -ggdb ./49_wcsftime.c  -o test_gcc
./test_gcc
indeterminate time: 2024-07-

$ make clang
clang --std=c11 -ggdb ./49_wcsftime.c  -o test_clang
./test_clang
indeterminate time: 2024-07-
```

GCC 和 LLVM 的行为一致，都是将能存储的部分转换完。

### 37. `wcrtomb` 中的编码错误

#### 描述

Whether an encoding error occurs if a wchar_t value that does not correspond to a member of the extended character set appears in the format string for a function in 7.29.2 or 7.29.5 and the specified semantics do not require that value to be processed by wcrtomb [7.29.1](https://port70.net/~nsz/c/c11/n1570.html#7.29.1).

如果 7.29.2 或 7.29.5 中函数的格式字符串中出现与扩展字符集成员不对应的 `wchar_t` 值，并且指定的语义不需要 `wcrtomb` 处理该值，是否会发生编码错误。

Arguments to the functions in this subclause may point to arrays containing wchar_t values that do not correspond to members of the extended character set. Such values shall be processed according to the specified semantics, except that it is unspecified whether an encoding error occurs if such a value appears in the format string for a function in [7.29.2](https://port70.net/~nsz/c/c11/n1570.html#7.29.2) or [7.29.5](https://port70.net/~nsz/c/c11/n1570.html#7.29.5) and the specified semantics do not require that value to be processed by wcrtomb.

在这个小节中的函数的参数可能指向包含 `wchar_t` 值的数组，这些值不对应于扩展字符集的成员。这样的值应当根据指定的语义进行处理，除非在格式字符串中出现这样的值且指定的语义不要求通过wcrtomb处理它，在这种情况下是否发生编码错误是未指定的。 具体来说，如果函数在 [7.29.2](https://port70.net/~nsz/c/c11/n1570.html#7.29.2) 或 [7.29.5](https://port70.net/~nsz/c/c11/n1570.html#7.29.5) 中使用格式字符串，并且指定的语义不需要通过 `wcrtomb` 处理该值，则是否发生编码错误是未指定的。

#### 代码

```c
#include <locale.h>
#include <stdio.h>
#include <time.h>
#include <wchar.h>

int main() {
  wchar_t buffer[80];
  struct tm time_info;

  setlocale(LC_ALL, "");

  time_info.tm_year = 2024 - 1900;
  time_info.tm_mon = 6;
  time_info.tm_mday = 15;
  time_info.tm_hour = 10;
  time_info.tm_min = 30;
  time_info.tm_sec = 0;
  time_info.tm_isdst = -1;

  wchar_t format[] = L"%Y-%m-%d %H:%M:%S \uFFFF";
  size_t result =
      wcsftime(buffer, sizeof(buffer) / sizeof(wchar_t), format, &time_info);

  printf("time: %ls\n", buffer);
  printf("size: %ld\n", sizeof(buffer) / sizeof(wchar_t));
  return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./50_wcetomb_en.c  -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./50_wcetomb_en.c  -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
```

### 38. 发生编码错误后的转换状态

#### 描述

The conversion state after an encoding error occurs [7.29.6.3.2](https://port70.net/~nsz/c/c11/n1570.html#7.29.6.3.2), [7.29.6.3.3](https://port70.net/~nsz/c/c11/n1570.html#7.29.6.3.3), [7.29.6.4.1](https://port70.net/~nsz/c/c11/n1570.html#7.29.6.4.1), [7.29.6.4.2](https://port70.net/~nsz/c/c11/n1570.html#7.29.6.4.2),

发生编码错误后的转换状态

`wcrtomb` 函数返回数组对象中存储的字节数（包括任何移位序列）。当参数 `wc` 不是有效的宽字符时，会发生编码错误：函数将宏 `EILSEQ` 的值存储在 `errno` 中并返回 `(size_t)(-1)` ；转换状态未指定。

该行为是对库函数的描述，与 GCC 和 LLVM 之间的差异无关。所以 GCC 和 LLVM 编译后的结果的行为一致。

### 39. IEC 60559 浮点到整数转换过程中出现 “invalid” 浮点异常时的结果值

#### 描述

The resulting value when the ''invalid'' floating-point exception is raised during IEC 60559 floating to integer conversion [F.4](https://port70.net/~nsz/c/c11/n1570.html#F.4).

IEC 60559 浮点到整数转换过程中出现 “invalid” 浮点异常时的结果值

如果浮点值是无穷大或 NaN，或者浮点值的整数部分超出整数类型的范围，则会引发 “invalid” 浮点异常，并且结果值未指定。

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <fenv.h>
#include <float.h>
#include <limits.h>
#include <stdbool.h>

void test_conversion_exceptions(double value) {
    feclearexcept(FE_ALL_EXCEPT);
    int int_value = (int)value;

    int flags = fetestexcept(FE_INVALID | FE_INEXACT);

    printf("Testing value: %f\n", value);
    printf("Converted integer: %d\n", int_value);
}

int main() {
    double values[] = {
        DBL_MAX,           // 浮点最大值，超出 int 范围
        -DBL_MAX,          // 浮点最小值，超出 int 范围
        NAN,               // 非数 (NaN)
        INFINITY,          // 正无穷大
        -INFINITY,         // 负无穷大
        1.5,               // 非整数浮点值
        42.0               // 整数浮点值
    };

    size_t num_values = sizeof(values) / sizeof(values[0]);

    for (size_t i = 0; i < num_values; ++i) {
        test_conversion_exceptions(values[i]);
        printf("\n");
    }

    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./52_float_invaild.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./52_float_invaild.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Testing value: 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
Converted integer: -2147483648

Testing value: -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
Converted integer: -2147483648

Testing value: nan
Converted integer: -2147483648

Testing value: inf
Converted integer: -2147483648

Testing value: -inf
Converted integer: -2147483648

Testing value: 1.500000
Converted integer: 1
FE_INEXACT exception raised.

Testing value: 42.000000
Converted integer: 42
```

### 40. 将非整数 IEC 60559 浮点值转换为整数是否会引发 “inexact” 浮点异常

#### 描述

Whether conversion of non-integer IEC 60559 floating values to integer raises the ''inexact'' floating-point exception [F.4](https://port70.net/~nsz/c/c11/n1570.html#F.4)

将非整数 IEC 60559 浮点值转换为整数是否会引发 “inexact” 浮点异常

If the integer type is _Bool, [6.3.1.2](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.2) applies and no floating-point exceptions are raised (even for NaN). Otherwise, if the floating value is infinite or NaN or if the integral part of the floating value exceeds the range of the integer type, then the ''invalid'' floating- point exception is raised and the resulting value is unspecified. Otherwise, the resulting value is determined by [6.3.1.4](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.4). Conversion of an integral floating value that does not exceed the range of the integer type raises no floating-point exceptions; whether conversion of a non-integral floating value raises the ''inexact'' floating-point exception is unspecified

如果整数类型是 _Bool，则应用 [6.3.1.2](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.2) 的规则，并且不会引发任何浮点异常（即使是 NaN）。否则，如果浮点值是无穷大或 NaN，或者如果浮点值的整数部分超过了整数类型的范围，则会引发 “invalid” 浮点异常，并且结果值是未指定的。否则，结果值由 [6.3.1.4](https://port70.net/~nsz/c/c11/n1570.html#6.3.1.4) 确定。将不超过整数类型范围的整数浮点值转换为整数不会引发浮点异常；而非整数浮点值的转换是否引发 “inexact” 浮点异常则是未指定的。

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <fenv.h>

void test_inexact_exception(double value) {
    feclearexcept(FE_ALL_EXCEPT);

    int int_value = (int)value;

    if (fetestexcept(FE_INEXACT)) {
        printf("Value: %f, Converted Integer: %d - FE_INEXACT exception was raised.\n", value, int_value);
    } else {
        printf("Value: %f, Converted Integer: %d - FE_INEXACT exception was NOT raised.\n", value, int_value);
    }
}

int main() {
    double values[] = {
        1.5,
        2.75,
        -3.25,
        0.0,
        -0.0
    };

    size_t num_values = sizeof(values) / sizeof(values[0]);

    for (size_t i = 0; i < num_values; ++i) {
        test_inexact_exception(values[i]);
    }

    return 0;
}
```

#### 描述

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./53_float+inexact.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./53_float+inexact.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Value: 1.500000, Converted Integer: 1 - FE_INEXACT exception was raised.
Value: 2.750000, Converted Integer: 2 - FE_INEXACT exception was raised.
Value: -3.250000, Converted Integer: -3 - FE_INEXACT exception was raised.
Value: 0.000000, Converted Integer: 0 - FE_INEXACT exception was NOT raised.
Value: -0.000000, Converted Integer: 0 - FE_INEXACT exception was NOT raised.
```

### 41. `<math.h>` 中的库函数是否或何时在符合 IEC 60559 的实现中引发 “inexact” 浮点异常

#### 描述

Whether or when library functions in <math.h> raise the ''inexact'' floating-point exception in an IEC 60559 conformant implementation [F.10](https://port70.net/~nsz/c/c11/n1570.html#F.10).

`<math.h>` 中的库函数是否或何时在符合 IEC 60559 的实现中引发 “inexact” 浮点异常

“Inexact” 浮点异常通常发生在算术运算的结果不能精确地表示为浮点数时。这意味着结果需要四舍五入到最接近的可表示值。 

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <fenv.h>

void test_inexact_exception(double (*math_func)(double), double value, const char *func_name) {
    feclearexcept(FE_ALL_EXCEPT);

    double result = math_func(value);

    if (fetestexcept(FE_INEXACT)) {
        printf("Function: %s, Value: %f, Result: %f - FE_INEXACT exception was raised.\n", func_name, value, result);
    } else {
        printf("Function: %s, Value: %f, Result: %f - FE_INEXACT exception was NOT raised.\n", func_name, value, result);
    }
}

int main() {
    struct {
        double (*func)(double);
        const char *name;
        double value;
    } tests[] = {
        { sqrt, "sqrt", 2.0 },
        { log, "log", 2.71828 },
        { sin, "sin", 0.5 },
        { cos, "cos", 1.0 },
        { exp, "exp", 1.0 }
    };

    size_t num_tests = sizeof(tests) / sizeof(tests[0]);

    for (size_t i = 0; i < num_tests; ++i) {
        test_inexact_exception(tests[i].func, tests[i].value, tests[i].name);
    }

    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./54_math_inexact.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./54_math_inexact.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Function: sqrt, Value: 2.000000, Result: 1.414214 - FE_INEXACT exception was raised.
Function: log, Value: 2.718280, Result: 0.999999 - FE_INEXACT exception was raised.
Function: sin, Value: 0.500000, Result: 0.479426 - FE_INEXACT exception was raised.
Function: cos, Value: 1.000000, Result: 0.540302 - FE_INEXACT exception was raised.
Function: exp, Value: 1.000000, Result: 2.718282 - FE_INEXACT exception was raised.
```

### 42. `<math.h>` 中的库函数是否或何时在符合 IEC 60559 的实现中引发不应有的 “underflow” 浮点异常

#### 描述

Whether or when library functions in <math.h> raise an undeserved ''underflow'' floating-point exception in an IEC 60559 conformant implementation [F.10](https://port70.net/~nsz/c/c11/n1570.html#F.10).

<math.h> 中的库函数是否或何时在符合 IEC 60559 的实现中引发不应有的 “underflow” 浮点异常

当数学函数的结果太小，无法在指定的浮点类型中准确表示时，会发生 underflow 错误。这种情况下，函数通常会返回一个值，其大小不超过该类型中最小的正规化正数。

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <fenv.h>

void test_underflow_exception(double (*math_func)(double), double value, const char *func_name) {
    feclearexcept(FE_ALL_EXCEPT);

    double result = math_func(value);

    if (fetestexcept(FE_UNDERFLOW)) {
        printf("Function: %s, Value: %e, Result: %e - FE_UNDERFLOW exception was raised.\n", func_name, value, result);
    } else {
        printf("Function: %s, Value: %e, Result: %e - FE_UNDERFLOW exception was NOT raised.\n", func_name, value, result);
    }
}

int main() {
    struct {
        double (*func)(double);
        const char *name;
        double value;
    } tests[] = {
        { sqrt, "sqrt", 1e-300 },
        { log, "log", 1e-300 },
        { exp, "exp", -1e300 },
        { sin, "sin", 1e-300 },
        { cos, "cos", 1e-300 },
    };

    size_t num_tests = sizeof(tests) / sizeof(tests[0]);

    for (size_t i = 0; i < num_tests; ++i) {
        test_underflow_exception(tests[i].func, tests[i].value, tests[i].name);
    }

    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./55_underflow.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./55_underflow.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Function: sqrt, Value: 1.000000e-300, Result: 1.000000e-150 - FE_UNDERFLOW exception was NOT raised.
Function: log, Value: 1.000000e-300, Result: -6.907755e+02 - FE_UNDERFLOW exception was NOT raised.
Function: exp, Value: -1.000000e+300, Result: 0.000000e+00 - FE_UNDERFLOW exception was raised.
Function: sin, Value: 1.000000e-300, Result: 1.000000e-300 - FE_UNDERFLOW exception was NOT raised.
Function: cos, Value: 1.000000e-300, Result: 1.000000e+00 - FE_UNDERFLOW exception was NOT raised.
```

### 43. `frexp` 存储的 `NaN` 或无穷大的指数值

#### 描述

The exponent value stored by frexp for a NaN or infinity [F.10.3.4](https://port70.net/~nsz/c/c11/n1570.html#F.10.3.4).

`frexp` 函数将浮点值拆分为分数和指数。分数由 `frexp` 函数返回，指数存储在 `exp` 变量中。

`frexp` 存储的 NaN 或无穷大的指数值

`frexp(NaN, exp)` 在 `exp` 指向的对象中存储一个未指定的值（并返回 NaN）

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <fenv.h>
#include <float.h>

int main() {
    int exp;
    double value = NAN;
    double result = frexp(value, &exp);

    printf("frexp(NaN, &exp) returned: %f\n", result);
    printf("Value stored in exp: %d\n", exp);

    if (isnan(result)) {
        printf("Result is NaN as expected.\n");
    } else {
        printf("Unexpected result: %f\n", result);
    }

    printf("Unspecified value stored in exp: %d\n", exp);

    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./56_frexp.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./56_frexp.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
frexp(NaN, &exp) returned: nan
Value stored in exp: 0
Result is NaN as expected.
Unspecified value stored in exp: 0
```

### 44. 如果舍入值超出返回类型的范围，则 `lrint`、`llrint`、`lround` 和 `llround` 函数返回的数值结果

#### 描述

The numeric result returned by the lrint, llrint, lround, and llround functions if the rounded value is outside the range of the return type [F.10.6.5](https://port70.net/~nsz/c/c11/n1570.html#F.10.6.5), [F.10.6.7](https://port70.net/~nsz/c/c11/n1570.html#F.10.6.7).

这些函数使用当前舍入方向将其参数四舍五入为最接近的整数值

#### 代码

```c
#include <stdio.h>
#include <math.h>
#include <errno.h>
#include <limits.h>
#include <fenv.h>

void test_lrint(double value) {
    errno = 0;
    feclearexcept(FE_ALL_EXCEPT);
    long int result = lrint(value);

    printf("lrint(%f) = %ld\n", value, result);
    if (errno == ERANGE) {
        printf("Range error occurred.\n");
    }
    if (fetestexcept(FE_INVALID)) {
        printf("Invalid floating-point exception occurred.\n");
    }
}

void test_llrint(double value) {
    errno = 0;
    feclearexcept(FE_ALL_EXCEPT);
    long long int result = llrint(value);

    printf("llrint(%f) = %lld\n", value, result);
    if (errno == ERANGE) {
        printf("Range error occurred.\n");
    }
    if (fetestexcept(FE_INVALID)) {
        printf("Invalid floating-point exception occurred.\n");
    }
}

void test_lround(double value) {
    errno = 0;
    feclearexcept(FE_ALL_EXCEPT);
    long int result = lround(value);

    printf("lround(%f) = %ld\n", value, result);
    if (errno == ERANGE) {
        printf("Range error occurred.\n");
    }
    if (fetestexcept(FE_INVALID)) {
        printf("Invalid floating-point exception occurred.\n");
    }
}

void test_llround(double value) {
    errno = 0;
    feclearexcept(FE_ALL_EXCEPT);
    long long int result = llround(value);

    printf("llround(%f) = %lld\n", value, result);
    if (errno == ERANGE) {
        printf("Range error occurred.\n");
    }
    if (fetestexcept(FE_INVALID)) {
        printf("Invalid floating-point exception occurred.\n");
    }
}

int main() {
    double large_value = (double)LLONG_MAX + 1e10;
    double small_value = -(double)LLONG_MAX - 1e10;

    printf("Testing lrint:\n");
    test_lrint(large_value);
    test_lrint(small_value);

    printf("\nTesting llrint:\n");
    test_llrint(large_value);
    test_llrint(small_value);

    printf("\nTesting lround:\n");
    test_lround(large_value);
    test_lround(small_value);

    printf("\nTesting llround:\n");
    test_llround(large_value);
    test_llround(small_value);

    return 0;
}
```

#### 描述

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./57_lrint.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./57_lrint.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
Testing lrint:
lrint(9223372046854774784.000000) = -9223372036854775808
Invalid floating-point exception occurred.
lrint(-9223372046854774784.000000) = -9223372036854775808
Invalid floating-point exception occurred.

Testing llrint:
llrint(9223372046854774784.000000) = -9223372036854775808
Invalid floating-point exception occurred.
llrint(-9223372046854774784.000000) = -9223372036854775808
Invalid floating-point exception occurred.

Testing lround:
lround(9223372046854774784.000000) = -9223372036854775808
Invalid floating-point exception occurred.
lround(-9223372046854774784.000000) = -9223372036854775808
Invalid floating-point exception occurred.

Testing llround:
llround(9223372046854774784.000000) = -9223372036854775808
Invalid floating-point exception occurred.
llround(-9223372046854774784.000000) = -9223372036854775808
Invalid floating-point exception occurred.
```

### 45. 在 IEC 60559 兼容实现中，针对某些特殊情况的多个数学函数的复杂结果的一部分的符号

#### 描述

The sign of one part of the complex result of several math functions for certain special cases in IEC 60559 compatible implementations [G.6.1.1](https://port70.net/~nsz/c/c11/n1570.html#G.6.1.1), [G.6.2.2](https://port70.net/~nsz/c/c11/n1570.html#G.6.2.2), [G.6.2.3](https://port70.net/~nsz/c/c11/n1570.html#G.6.2.3), [G.6.2.4](https://port70.net/~nsz/c/c11/n1570.html#G.6.2.4), [G.6.2.5](https://port70.net/~nsz/c/c11/n1570.html#G.6.2.5), [G.6.2.6](https://port70.net/~nsz/c/c11/n1570.html#G.6.2.6), [G.6.3.1](https://port70.net/~nsz/c/c11/n1570.html#G.6.3.1), [G.6.4.2](https://port70.net/~nsz/c/c11/n1570.html#G.6.4.2).

在 IEC 60559 兼容实现中，针对某些特殊情况的多个数学函数的复杂结果的一部分的符号

该行为是对库函数的描述，与 GCC 和 LLVM 之间的差异无关。所以 GCC 和 LLVM 编译后的结果的行为一致。

### 46. 赋值运算符的操作数的评估顺序

#### 描述

The order in which the operands of an assignment operator are evaluated [6.5.16](https://port70.net/~nsz/c/c11/n1570.html#6.5.16).

An assignment operator stores a value in the object designated by the left operand. An assignment expression has the value of the left operand after the assignment, but is not an lvalue. The type of an assignment expression is the type the left operand would have after lvalue conversion. The side effect of updating the stored value of the left operand is sequenced after the value computations of the left and right operands. The evaluations of the operands are unsequenced.

赋值运算符将值存储在左操作数指定的对象中。赋值表达式具有赋值后左操作数的值，但不是左值。赋值表达式的类型是左操作数在左值转换后将具有的类型。更新左操作数的存储值的副作用在左操作数和右操作数的值计算之后排序。操作数的计算是无序的。

#### 代码

```c
#include <stdio.h>
int main(void) {
    int x = 5;
    int *y = &x;
    int z = (x = 3) + ++(*y);
    printf("z: %d\n", z);
    printf("x: %d\n", x);
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./19_eval_order.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./19_eval_order.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
z: 7
x: 4
```

### 47. 对内联函数的调用是使用函数的内联定义还是外部定义

#### 描述

Whether a call to an inline function uses the inline definition or the external definition of the function [6.7.4](https://port70.net/~nsz/c/c11/n1570.html#6.7.4).

对内联函数的调用是使用函数的内联定义还是外部定义

#### 代码

```c
// 21_inline.c
#include <stdio.h>

inline void foo() {
    puts("inline");
}

// 21_main.c
#include <stdio.h>

void foo() {
    puts("external");
}
int main() {
    foo();
    foo();
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./21_inline.c ./21_main.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./21_inline.c ./21_main.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
external
external
```

GCC 和 LLVM 的实现一直，选择外部实现而非内联实现。

### 48. `sizeof` 内的表达式求值

#### 描述

Whether or not a size expression is evaluated when it is part of the operand of a sizeof operator and changing the value of the size expression would not affect the result of the operator [6.7.6.2](https://port70.net/~nsz/c/c11/n1570.html#6.7.6.2).

当 `sizeof` 表达式是 `sizeof` 运算符的操作数的一部分时，是否对大小表达式进行求值，并且更改大小表达式的值不会影响运算符的结果

该未指定行为针对的是内部 `sizeof` 表达式不会对外部影响的情况下，是否要计算该 `sizeof` 表达式。本身是否计算都对结果没有影响，所以 GCC 和 LLVM 编译后的结果也不会有区别。

### 49. 初始化程序中初始化列表表达式中任何副作用发生的顺序

#### 描述

The order in which any side effects occur among the initialization list expressions in an initializer [6.7.9](https://port70.net/~nsz/c/c11/n1570.html#6.7.9).

初始化程序中初始化列表表达式中任何副作用发生的顺序

#### 代码

```c
#include <stdio.h>

int func1() {
  printf("func1 called\n");
  return 1;
}

int func2() {
  printf("func2 called\n");
  return 2;
}

int func3() {
  printf("func3 called\n");
  return 3;
}

int main() {
  int arr[3] = {func1(), func2(), func3()};

  printf("arr = {%d, %d, %d}\n", arr[0], arr[1], arr[2]);

  return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./23_init_order.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./23_init_order.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
func1 called
func2 called
func3 called
arr = {1, 2, 3}
```

从结果可以看出，GCC 和 LLVM 对该行为的实现表现一致。

### 50. 函数参数存储的布局

#### 描述

The layout of storage for function parameters [6.9.1](https://port70.net/~nsz/c/c11/n1570.html#6.9.1).

函数参数的布局更多受到操作系统的制约，比如类 Unix 会遵循 System V ABI，在 amd64 架构中，整数类型的参数前 6 个会使用寄存器传递，而 Windows 也类似，如果是 x86 架构则是在栈中传递，此外还有调用约定，分为 Cdecl，Stdcall 和 Fastcall。这与编译器无关，GCC 和 LLVM 编译行为保持一致。

### 51. 宏的嵌套替换

#### 描述

When a fully expanded macro replacement list contains a function-like macro name as its last preprocessing token and the next preprocessing token from the source file is a (, and the fully expanded replacement of that macro ends with the name of the first macro and the next preprocessing token from the source file is again a (, whether that is considered a nested replacement [6.10.3](https://port70.net/~nsz/c/c11/n1570.html#6.10.3).

当完全展开的宏替换列表包含一个类似函数的宏名称作为其最后一个预处理标记，并且源文件中的下一个预处理标记是 `(`，并且该宏的完全展开替换以第一个宏的名称结尾，并且源文件中的下一个预处理标记再次是 `(`，则这是否被视为嵌套替换

#### 代码

```c
#define MACRO_A MACRO_B()
#define MACRO_B MACRO_A()

int main(void) {
    int a = MACRO_A;
    return 0;
}
```

这段代码无法通过编译器检查

#### 结果

```bash
$ make gcc
gcc --std=c11 -ggdb ./25_macro.c -o test_gcc
./25_macro.c: In function ‘main’:
./25_macro.c:2:17: error: implicit declaration of function ‘MACRO_A’ [-Wimplicit-function-declaration]
    2 | #define MACRO_B MACRO_A()
      |                 ^~~~~~~
./25_macro.c:1:17: note: in expansion of macro ‘MACRO_B’
    1 | #define MACRO_A MACRO_B()
      |                 ^~~~~~~
./25_macro.c:5:13: note: in expansion of macro ‘MACRO_A’
    5 |     int a = MACRO_A;
      |             ^~~~~~~
./25_macro.c:2:17: error: called object is not a function or function pointer
    2 | #define MACRO_B MACRO_A()
      |                 ^~~~~~~
./25_macro.c:1:17: note: in expansion of macro ‘MACRO_B’
    1 | #define MACRO_A MACRO_B()
      |                 ^~~~~~~
./25_macro.c:5:13: note: in expansion of macro ‘MACRO_A’
    5 |     int a = MACRO_A;
      |             ^~~~~~~
make: *** [Makefile:12: gcc] Error 1

$ make clang
clang --std=c11 -ggdb ./25_macro.c -o test_clang
./25_macro.c:5:13: error: call to undeclared function 'MACRO_A'; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration]
    5 |     int a = MACRO_A;
      |             ^
./25_macro.c:1:17: note: expanded from macro 'MACRO_A'
    1 | #define MACRO_A MACRO_B()
      |                 ^
./25_macro.c:2:17: note: expanded from macro 'MACRO_B'
    2 | #define MACRO_B MACRO_A()
      |                 ^
./25_macro.c:5:13: error: called object type 'int' is not a function or function pointer
    5 |     int a = MACRO_A;
      |             ^~~~~~~
./25_macro.c:1:24: note: expanded from macro 'MACRO_A'
    1 | #define MACRO_A MACRO_B()
      |                 ~~~~~~~^
2 errors generated.
make: *** [Makefile:15: clang] Error 1
```

### 52. 宏替换期间 `#` 和 `##` 操作的评估顺序

#### 描述

The order in which # and ## operations are evaluated during macro substitution [6.10.3.2](https://port70.net/~nsz/c/c11/n1570.html#6.10.3.2), [6.10.3.3](https://port70.net/~nsz/c/c11/n1570.html#6.10.3.3).

For both object-like and function-like macro invocations, before the replacement list is reexamined for more macro names to replace, each instance of a ## preprocessing token in the replacement list (not from an argument) is deleted and the preceding preprocessing token is concatenated with the following preprocessing token. Placemarker preprocessing tokens are handled specially: concatenation of two placemarkers results in a single placemarker preprocessing token, and concatenation of a placemarker with a non-placemarker preprocessing token results in the non-placemarker preprocessing token. If the result is not a valid preprocessing token, the behavior is undefined. The resulting token is available for further macro replacement. The order of evaluation of ## operators is unspecified.

对于 object-like 和 function-like 宏调用，在替换列表被重新检查以替换更多宏名之前，替换列表中的每个 `##` 预处理符（而不是来自参数的）都会被删除，且前面的预处理符会与后面的预处理符连接。占位符预处理符会特殊处理：两个占位符的连接结果是单个占位符预处理符，而占位符与非占位符预处理符的连接结果是非占位符预处理符。如果结果不是一个有效的预处理符，则行为是未定义的。结果的符号可用于进一步的宏替换。`##` 操作符的评估顺序是未指定的。

#### 代码

```c
#include <stdio.h>

#define TO_STRING(x) #x
#define CONCAT(a, b) a##b
#define COMBINE(a, b) TO_STRING(CONCAT(a, b))

int main() {
    printf("%s\n", TO_STRING(123));
    printf("%d\n", CONCAT(12, 34));
    printf("%s\n", COMBINE(56, 78));
    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb ./26_macro_order.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb ./26_macro_order.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
123
1234
CONCAT(56, 78)
```

### 53. 当将值存储在具有多个该值的对象表示形式的对象中时使用的表示形式

#### 描述

The representation used when storing a value in an object that has more than one object representation for that value [6.2.6.1](https://port70.net/~nsz/c/c11/n1570.html#6.2.6.1).

当将值存储在具有多个该值的对象表示形式的对象中时使用的表示形式

Where an operator is applied to a value that has more than one object representation, which object representation is used shall not affect the value of the result. Where a value is stored in an object using a type that has more than one object representation for that value, it is unspecified which representation is used, but a trap representation shall not be generated.

如果将运算符应用于具有多个对象表示形式的值，则使用哪种对象表示形式不应影响结果的值。如果使用具有多个对象表示形式的类型将值存储在对象中对于该值，未指定使用哪种表示形式，但不应生成陷阱表示形式。

#### 代码

```c
#include <stdio.h>
#include <string.h>

int main() {
  float a = -0.0;
  float b = 0.0;
  unsigned char a_byte[sizeof(a)];
  unsigned char b_byte[sizeof(b)];

  memcpy(a_byte, &a, sizeof(a));
  memcpy(b_byte, &b, sizeof(b));
  for (int i = 0; i < sizeof(a_byte); ++i) {
    printf("%x", a_byte[i]);
  }
  puts("");
  for (int i = 0; i < sizeof(b_byte); ++i) {
    printf("%x", b_byte[i]);
  }
  puts("");
  return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb  ./12_store_v.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./12_store_v.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
00080
0000
```

### 54. 类型表示的许多方面

#### 描述

Many aspects of the representations of types [6.2.6](https://port70.net/~nsz/c/c11/n1570.html#6.2.6).

某些对象表示可能不代表对象类型的值。如果对象的存储值具有这种表示并且由非字符类型的左值表达式读取，则行为未定义。如果这种表示是通过修改对象的全部或部分的非字符类型左值表达式产生的，则行为未定义。这种表示称为陷阱表示。

#### 代码

```c
#include <stdint.h>
#include <stdio.h>

int main() {
  union {
    uint32_t u32;
    float f;
  } u;

  u.f = 3.14f;

  printf("uint32_t value: 0x%x\n", u.u32);

  return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb  ./9_type.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./9_type.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
uint32_t value: 0x4048f5c3
```

## GCC 与 LLVM 的行为不一致

### 1. 子表达式的求值顺序和副作用发生的顺序，函数调用 ()、&&、||、? : 和逗号运算符除外

The order in which subexpressions are evaluated and the order in which side effects take place, except as specified for the function-call (), &&, ||, ? :, and comma operators [6.5](https://port70.net/~nsz/c/c11/n1570.html#6.5).

子表达式的求值顺序和副作用发生的顺序，函数调用 ()、&&、||、? : 和逗号运算符除外

If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings

如果标量对象上的副作用相对于同一标量对象上的不同副作用或使用同一标量对象的值的值计算是无序的，则该行为是未定义的。如果表达式的子表达式有多个允许的排序，并且在任何排序中出现此类未排序的副作用，则行为未定义

```c
#include <stdio.h>

int main(void) {
  int a = 1, b = 2;
  printf("(a + 1) * (b + 2): %d\n", (a + 1) * (b + 2));
  return 0;
}
```

```bash
$ make cmp
gcc --std=c11 -ggdb  ./16_order.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./16_order.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出一致
(a + 1) * (b + 2): 8
```

这里子表达式的执行顺序是一致的，可以对程序反汇编证明:

```bash
$ objdump --disassemble=main test_gcc

test_gcc:     file format elf64-x86-64


Disassembly of section .init:

Disassembly of section .plt:

Disassembly of section .text:

0000000000001149 <main>:
    1149:       55                      push   %rbp
    114a:       48 89 e5                mov    %rsp,%rbp
    114d:       48 83 ec 10             sub    $0x10,%rsp
    1151:       48 8d 05 ac 0e 00 00    lea    0xeac(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    1158:       48 89 c7                mov    %rax,%rdi
    115b:       e8 d0 fe ff ff          call   1030 <puts@plt>
    1160:       c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%rbp)
    1167:       c7 45 fc 02 00 00 00    movl   $0x2,-0x4(%rbp)
    116e:       8b 45 f8                mov    -0x8(%rbp),%eax
    1171:       8d 50 01                lea    0x1(%rax),%edx
    1174:       8b 45 fc                mov    -0x4(%rbp),%eax
    1177:       83 c0 02                add    $0x2,%eax
    117a:       0f af c2                imul   %edx,%eax
    117d:       89 c6                   mov    %eax,%esi
    117f:       48 8d 05 83 0e 00 00    lea    0xe83(%rip),%rax        # 2009 <_IO_stdin_used+0x9>
    1186:       48 89 c7                mov    %rax,%rdi
    1189:       b8 00 00 00 00          mov    $0x0,%eax
    118e:       e8 ad fe ff ff          call   1040 <printf@plt>
    1193:       b8 00 00 00 00          mov    $0x0,%eax
    1198:       c9                      leave
    1199:       c3                      ret

Disassembly of section .fini:

$ objdump --disassemble=main test_clang

test_clang:     file format elf64-x86-64


Disassembly of section .init:

Disassembly of section .plt:

Disassembly of section .text:

0000000000001150 <main>:
    1150:       55                      push   %rbp
    1151:       48 89 e5                mov    %rsp,%rbp
    1154:       48 83 ec 10             sub    $0x10,%rsp
    1158:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
    115f:       48 8d 3d 9e 0e 00 00    lea    0xe9e(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>
    1166:       e8 c5 fe ff ff          call   1030 <puts@plt>
    116b:       c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%rbp)
    1172:       c7 45 f4 02 00 00 00    movl   $0x2,-0xc(%rbp)
    1179:       8b 75 f8                mov    -0x8(%rbp),%esi
    117c:       83 c6 01                add    $0x1,%esi
    117f:       8b 45 f4                mov    -0xc(%rbp),%eax
    1182:       83 c0 02                add    $0x2,%eax
    1185:       0f af f0                imul   %eax,%esi
    1188:       48 8d 3d 7b 0e 00 00    lea    0xe7b(%rip),%rdi        # 200a <_IO_stdin_used+0xa>
    118f:       b0 00                   mov    $0x0,%al
    1191:       e8 aa fe ff ff          call   1040 <printf@plt>
    1196:       31 c0                   xor    %eax,%eax
    1198:       48 83 c4 10             add    $0x10,%rsp
    119c:       5d                      pop    %rbp
    119d:       c3                      ret

Disassembly of section .fini:
```

这里都是将 `a`, `b` 的值压栈，之后执行 `(a +  1)` 的部分，随后执行 `(b + 2)`，最后相乘。


### 2. 函数调用中函数指示符、参数以及参数中的子表达式的求值顺序

#### 描述

The order in which the function designator, arguments, and subexpressions within the arguments are evaluated in a function call [6.5.2.2](https://port70.net/~nsz/c/c11/n1570.html#6.5.2.2).

函数调用中函数指示符、参数以及参数中的子表达式的求值顺序

The order of evaluation of the function designator, the actual arguments, and subexpressions within the actual arguments is unspecified, but there is a sequence point before the actual call.

函数指示符、实际参数和实际参数中的子表达式的求值顺序未指定，但在实际调用之前有一个序列点。

#### 代码

```c
#include <stdio.h>

int f1(int *x) {
  *x = 1;
  return 1;
}
int f2(int *x) {
  *x = 2;
  return 1;
}

int func(int a, int b) { return a + b; }

int main(void) {
  int x = 1;
  printf("func(): %d\n", func(f1(&x), f2(&x)));
  printf("x: %d\n", x);
  return 0;
}
```

#### 结果

对于上述代码来说，GCC 和 LLVM 的处理是不一致的，`func()` 中对 `f1()` 和 `f2()` 调用顺序有区别

```bash
$ make cmp
gcc --std=c11 -ggdb  ./17_func_call.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./17_func_call.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出不一致
func(): 2
x: 1

func(): 2
x: 2
```

其中，gcc 会先执行 `f1()`，而 llvm 则是后执行 `f1()`。


### 3. 当执行从使用 FENV_ACCESS ''off'' 翻译的程序部分转移到使用 FENV_ACCESS ''on'' 翻译的程序部分时，浮点状态标志的状态

#### 描述

The state of the floating-point status flags when execution passes from a part of the program translated with FENV_ACCESS ''off'' to a part translated with FENV_ACCESS ''on'' [7.6.1](https://port70.net/~nsz/c/c11/n1570.html#7.6.1).

#### 代码

```c
#include <stdio.h>
#include <fenv.h>
#include <math.h>

#pragma STDC FENV_ACCESS OFF

int main() {
    fesetround(FE_DOWNWARD);
    double result = 1.0 / 0.0;
    if (fetestexcept(FE_DIVBYZERO)) {
        printf("Division by zero exception detected.\n");
    } else {
        printf("No exception detected.\n");
    }

    int round_mode = fegetround();
    if (round_mode == FE_DOWNWARD) {
        printf("Rounding mode is downward.\n"); 在 IEC 60559 兼容实现中，针对某些特殊情况的多个数学函数的复杂结果的一部分的符号

    } else {
        printf("Rounding mode is not downward.\n");
    }

    return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb -lm ./27_float_env.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb -lm ./27_float_env.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出不一致
Division by zero exception detected.
Rounding mode is downward.

No exception detected.
Rounding mode is downward.
```

从结果可以看出，GCC 和 LLVM 的实现并不一致，GCC 在设置 FENV_ACCESS 为 OFF 后依旧可以检测到浮点异常，但 LLVM 依赖于 FENV_ACCESS 的设置。

### 4. 整数表示中任何填充位的值

The values of any padding bits in integer representations [6.2.6.2](https://port70.net/~nsz/c/c11/n1570.html#6.2.6.2).

整数表示中任何填充位的值

For unsigned integer types other than unsigned char, the bits of the object representation shall be divided into two groups: value bits and padding bits (there need not be any of the latter). If there are N value bits, each bit shall represent a different power of 2 between 1 and 2N - 1, so that objects of that type shall be capable of representing values from 0 to 2N - 1 using a pure binary representation; this shall be known as the value representation. The values of any padding bits are unspecified

对于除 `unsigned char` 之外的无符号整数类型，对象表示的位应分为两组：值位和填充位（后者不需要任何）。如果有 N 个值位，则每个位应表示 1 到 2N - 1 之间的不同 2 的幂，以便该类型的对象应能够使用纯二进制表示来表示从 0 到 2N - 1 的值；这应称为值表示。任何填充位的值均未指定

#### 代码

```c
#include <stdint.h>
#include <stdio.h>

int main() {
  struct PaddedInt {
    unsigned int value : 31;
    unsigned int padding : 1;
  };

  union {
    struct PaddedInt paddedInt;
    unsigned int raw;
  } u;

  u.paddedInt.value = 123456;

  printf("Raw unsigned int value: 0x%x\n", u.raw);

  printf("PaddedInt value: %u\n", u.paddedInt.value);
  printf("Padding bit: %u\n", u.paddedInt.padding);

  return 0;
}
```

#### 结果

```bash
$ make cmp
gcc --std=c11 -ggdb  ./13_store_d.c -o test_gcc
./test_gcc > gcc_out
clang --std=c11 -ggdb  ./13_store_d.c -o test_clang
./test_clang > clang_out
./compare.sh
GCC 和 LLVM 输出不一致
Raw unsigned int value: 0x1e240
PaddedInt value: 123456
Padding bit: 0

Raw unsigned int value: 0x8001e240
PaddedInt value: 123456
Padding bit: 1
```

LLVM 会将 padding bit 为 1，而 GCC 则为 0。